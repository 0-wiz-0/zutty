* Zutty - Zero-cost Unicode Teletype

Zutty is a terminal emulator for the X Window System, functionally
similar to several other X terminal emulators such as xterm, rxvt and
countless others. It is also similar to other, newer, GPU-accelerated
terminal emulators such as Alacritty and Kitty. What sets Zutty apart
is its focus on extremely efficient rendering, enabling it to perform
seamlessly in constrained environments where others struggle or fail.
At the same time, Zutty aims to implement a sufficiently complete
feature set to make it useful for a wide range of users, and strives
to conform to relevant (actual or de-facto) standards.

Zutty is written in straightforward C++ and only relies on OpenGL ES
3.1 for rendering, making it trivially portable to windowing systems
other than X and operating systems other than Linux. Zutty provides a
clean implementation written from scratch, resulting in a minimal,
maintainable, modern codebase unencumbered by historical baggage.

Zutty is released under the GNU General Public License (GPL) v3 or (at
your option) any later version. Please refer to the file LICENSE for
the full text of the license.

The main idea behind Zutty is the implementation of character video
memory via OpenGL ES 3.1. This video memory is just an array of cells
backing all character grid locations, containing Unicode character
codes plus color and other attributes. This memory area, allocated on
the GPU, is mapped to make it directly writable by the application.
This results in a very similar interface as to how one could write to
the screen by directly poking at physical video memory starting at
0xB8000 on the IBM PC. Zutty employs a "compute shader" running on the
GPU to read this video memory and render output pixels.

** Features

*** Font handling

We support a primary and optionally an alternate variant of the same
font, which will be used to render characters marked with the 'bold'
attribute. The bold font might not have all the glyphs of the
primary - in this case we fall back to rendering the glyph from the
primary font atlas.

**** Recommended fonts

The author of Zutty prefers the so-called "misc fixed" fonts that were
designed in the '80s in an era of much inferior computer displays.
These were the original fonts designed to be used with the
then-nascent X Window System, and their availability is universal.
There is a convenient range of sizes, several fonts have bold variants
and support thousands of international characters and symbols outside
ASCII. Zutty will work best with any of misc-fixed 6x13, 7x13, 7x14,
8x13, 9x15 and 9x18 (there are more, but these have a bold-face
alternate).

*** True color support
*** Synchronous and asynchronous scrolling
*** Double-size mode

This might be useful for HiDPI displays and as an escape hatch for
those presenting their screen to an audience.

*** X-clipboard / primary selection / copy-paste support

This is closely modeled after Xterm's functionality in this area.
Zutty adds the ability to select rectangular areas (useful if the
terminal is vertically split in e.g., emacs or tmux). Toggle with
space key while a selection adjustment is in progress (left or right
mouse button is held down).

- btn_left down: clear selection and set start of new one here

- movement while btn_left down: maintain selection between orig and
  point

- btn_left up: end selection here (if same as start pos, no
  selection); set mark to current pos; set selection text from
  highlighted area

- btn_right down: if there is a current selection, choose the start or
  end depending on which is nearer; make that end of the selection
  jump to point. If there is no selection, create a new selection
   between mark and point.

- movement while btn_right down: maintain selection

- btn_right up: stop following point with chosen selection endpoint,
  set selection text from highlighted area

- selectSnapTo is inherited from earlier if started with right click

- double-click: select word; triple-click: select line.
  multi-click is determined by time from mouse-up to mouse-down, the
  button might be held down for an extended period, and the pointer
  might move in between!

- switch to rectangular selection on Space while a selection area
  adjustment is in progress. In rectangular mode, effective snapTo
  mode is always Char, but the original snapTo setting is preserved in
  case the selection is toggled back to regular line-oriented mode.
  Rectangular selection mode toggle is preserved even across different
  selections.

- on scroll or output changing the highlighted area: remove
  highlighting (but continue to serve primary selection)

- scroll with highlighted area intact: move highlight w/scroll area

- terminal updates are held while mouse button left or right is down
  (without spinning the cpu!)

- Selection interface via OSC command sequences

- btn_middle up, shift+Ins: request (if not the owner) and paste
  selection content

- support bracketed paste mode

*** Shell resolution algorithm

The algorithm to determine the shell program to run closely resembles
Xterm behaviour and follows these steps:

0. Start with the [shell] argument (the last argument given after all
   valid options, if present).
1. Try to construct an absolute path taking $PATH into account;
   this includes resolving relative paths and trying elements of the
   list of $PATH entries until it resolves to an existing file.
2. Fall back on $SHELL, then the user's /etc/passwd shell entry
3. Use /bin/sh as a last resort
4. Validate the outcome of the above steps against the permitted shell
   entries found in /etc/shells; clear $SHELL if the program is not
   listed as a valid shell.

Note that in case a [shell] argument is *not* given, the "zutty.shell"
resource is consulted; if that is not set, the built-in default of
/bin/bash is used.

** Omissions and limitations

There are things that Zutty does not implement compared to other, more
commonly used X terminal emulators (xterm being the gold standard of
completeness here). The below list gives an overview of what is
missing.  Most of them are thought as being out of scope for Zutty,
but some are marked as possibly being implemented in the future.

- Zutty currently does not support scroll-back. It is easy and
  straightforward to use programs such as =screen= or =tmux= if you
  want persistent tty sessions with scrollback and lots of other bells
  and whistles, and Zutty supports this kind of usage very well.
  Therefore, scrollback has always been low on the list of priorities.
  However, we are not ideological about this and there might come a
  time when scroll-back will be implemented.

- Zutty is opinionated about the primacy of UTF-8, which means that
  non-UTF-8 interaction is generally not supported, not even via
  bridges such as =luit=.  DEC builtin character sets (such as the DEC
  Special Graphics, DEC Technical Characters, etc.) and the escape
  sequences to enable them are well implemented though, so users of
  any modern Linux environment should never run into trouble.

- Zutty is Unicode based, but it is a terminal emulator, not a general
  purpose Unicode program. Therefore it does not aim to implement the
  whole breadth and depth of glyph and language support that Unicode
  defines.  Currently not supported:
  - Characters with a code point above 0xFFFF (that is, outside of the
    Basic Multilingual Pane);
  - Bidirectional (right-to-left) text;
  - Composing characters (things that can only be represented as a
    base glyph plus one or more composing glyphs superimposed, even in
    Unicode NFC representation). This might possibly be implemented
    later if there is sufficient interest.
  - Possibly more esoteric features.

- Double-width characters (necessary for e.g., drawing CJK glyphs) are
  not supported. Double-height lines are likewise not supported.

- Rectangular area operations (introduced by the DEC VT400 series) are
  not supported. However, this set of features is optional and the
  terminal's self-identification message clearly states the absence of
  it, so conforming client applications should not run into any
  trouble. No fundamental technical reasons here other than the lack
  of pressing need.

- The mouse protocol implementation aims to be complete with the
  exception of highlight tracking mode that is not implemented. Mouse
  highlight tracking is a mode that requires cooperation from the
  client application; it is not clear if any software actively used in
  2020 needs this feature. Also, all events for mouse buttons above
  the conventional five (three buttons plus scroll wheel up/down) are
  discarded.

** Textures

*** Output image texture

Dimensions: according to the character grid size (window size, less
fraction-of-char border area at the bottom and right edges). This
texture is rendered onto the viewport area using a quad. All the work
of computing the terminal window content is done by the compute shader
that sets color values of individual pixels in this texture.

*** Glyph atlas texture

Dimensions: auto-computed based on the number of glyphs in the font
and the glyph dimensions, to produce a pixel size as close to square
as possible.

The maximum amount of characters rasterized from a font is 64k, and
both dimensions (in character positions) will fit into a single byte
(we determine the atlas dimensions to guarantee this).

Encoding: 1 byte per texel, gray-scale (0 = black, 255 = white)

The atlas texture is stored as a 2D array with one layer for each font
face loaded. The mapping from unicode code point to atlas grid
location is the same across fonts, and is determined by the primary
font (loaded into texture array index 0). Each subsequent layer starts
out as a copy of the primary atlas layer, with glyphs successively
overwritten for each defined code point in the alternate font. This
means that when referencing an alternate font, the shader does not
have to care about whether the alternate font has a glyph for the
given code point -- if nothing else, the primary font's glyph will be
present.

*** Unicode to Atlas position mapping texture

This is a 256x256 2D texture that maps all 16-bit unicode code points
to an atlas grid position. It is initialized with the GL data type
GL_LUMINANCE_ALPHA (two channels), from an array with two 8-bit
integers per texel (8 bits for either atlas grid coordinate).

This allows direct lookups for any 16 bit Unicode code point in the
shader and allows the simulated character video memory to take unicode
code points, simplifying the client.

If the value stored for atlas (row,col) is (0,0), that means there is
no glyph for that code point in the font. As a measure of convenience,
the font loader ensures that this is a blank glyph.

** Shader Storage Buffer objects

*** Input "character video memory"

An array of Cell structures, with total length according to the
terminal size (rows x cols in characters). This array constitutes the
character video memory as seen by the client, and can be manipulated
directly through a client-side mapping of the SSBO.

The values stored for each Cell:
- unicode code point
- attributes: font face, inverse video, underline, blink
- foreground color
- background color

Each cell takes up 12 bytes, with 3 bytes currently unused (available
for future extensions).

** Synchronization

The main event loop multiplexes on
- the pty master fd;
- the fd of the X connection socket.

Multiplexer timeouts are calculated according to the next screen
redraw, if one is already scheduled.

We want to support both synchronous and asynchronous scrolling.
Synchronous: we make sure that everything will be drawn before it gets
overwritten (cannot scroll more than one screen per refresh).
Asynchronous: process as many updates as possible between each
refresh, which occurs with a maximum rate equal to the display's
refresh rate.

** TODO

How does the vsync work?
EGL_KHR_wait_sync ?
