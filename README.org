* Zutty - Zero-cost Unicode Teletype

Zutty is a terminal emulator for the X Window System, functionally
similar to several other X terminal emulators such as xterm, rxvt and
countless others. It is also similar to other, newer, GPU-accelerated
terminal emulators such as Alacritty and Kitty. What sets Zutty apart
is its focus on providing the most efficient rendering technology
(from the host computer's perspective), enabling it to perform
seamlessly in extremely constrained environments, where others
(including the above alternatives) struggle or fail. As a bonus, it
provides unbeatable performance everywhere else, too.

Zutty is written in straightforward C++ and only relies on OpenGL ES
3.1, making it trivially portable to windowing systems other than X
and operating systems other than Linux (but this is left as an
exercise to anyone who needs to do so).

Zutty is released under the GNU General Public License (GPL) v3 or (at
your option) any later version. Please refer to the file LICENSE for
the full text of the license.

The main idea behind Zutty is the implementation of character video
memory via OpenGL ES 3.1. This video memory is just an array of cells
backing all character grid locations, containing character codes (16
bit Unicode) plus color and other attributes. This area is directly
writable by the application, very similar to how one could write to
the screen by directly poking at physical video memory starting at
0xB8000 on the IBM PC. Zutty employs a "compute shader" running on the
GPU to read this video memory and render pixels directly to the output
image.

** Features

*** Font handling

We support a primary and optionally an alternate variant of the same
font, which will be used to render characters marked with the 'bold'
attribute. The bold font might not have all the glyphs of the
primary - in this case we fall back to rendering the glyph from the
primary font atlas.

**** Recommended fonts

The author of Zutty prefers the so-called "misc fixed" fonts that were
designed in the '80s in an era of much inferior computer displays.
These were the original fonts designed to be used with the
then-nascent X Window System, and their availability is universal.
There is a convenient range of sizes, several fonts have bold variants
and support thousands of international characters and symbols outside
ASCII. Zutty will work best with any of misc-fixed 6x13, 7x13, 7x14,
8x13, 9x15 and 9x18 (there are more, but these have a bold-face
alternate).

*** True color support
*** Synchronous and asynchronous scrolling
*** Double-size mode

This might be useful for HiDPI displays and as an escape hatch for
those presenting their screen to an audience.

** Textures

*** Output image texture

Dimensions: according to the character grid size (window size, less
fraction-of-char border area at the bottom and right edges). This
texture is rendered onto the viewport area using a quad. All the work
of computing the terminal window content is done by the compute shader
that sets color values of individual pixels in this texture.

*** Glyph atlas texture

Dimensions: auto-computed based on the number of glyphs in the font
and the glyph dimensions, to produce a pixel size as close to square
as possible.

The maximum amount of characters rasterized from a font is 64k, and
both dimensions (in character positions) will fit into a single byte
(we determine the atlas dimensions to guarantee this).

Encoding: 1 byte per texel, gray-scale (0 = black, 255 = white)

The atlas texture is stored as a 2D array with one layer for each font
face loaded. The mapping from unicode code point to atlas grid
location is the same across fonts, and is determined by the primary
font (loaded into texture array index 0). Each subsequent layer starts
out as a copy of the primary atlas layer, with glyphs successively
overwritten for each defined code point in the alternate font. This
means that when referencing an alternate font, the shader does not
have to care about whether the alternate font has a glyph for the
given code point -- if nothing else, the primary font's glyph will be
present.

*** Unicode to Atlas position mapping texture

This is a 256x256 2D texture that maps all 16-bit unicode code points
to an atlas grid position. It is initialized with the GL data type
GL_LIMUNANCE_ALPHA, from an array with two 8-bit integers per texel (8
bits for either atlas grid coordinate).

This allows direct lookups for any 16 bit Unicode code point in the
shader and allows the simulated character video memory to take unicode
code points, simplifying the client.

If the value stored for atlas (row,col) is (0,0), that means there is
no glyph for that code point in the font. As a measure of convenience,
the font loader ensures that this is a blank glyph.

** Shader Storage Buffer objects

*** Input "character video memory"

An array of Cell structures, with total length according to the
terminal size (rows x cols in characters). This array constitutes the
character video memory as seen by the client, and can be manipulated
directly through a client-side mapping of the SSBO.

The values stored for each Cell:
- unicode code point
- attributes: font face, inverse video, underline, blink
- foreground color
- background color

Each cell takes up 12 bytes, with 3 bytes currently unused (available
for future extensions).

** Synchronization

The main event loop multiplexes on
- the pty master fd;
- the fd of the X connection socket.

Multiplexer timeouts are calculated according to the next screen
redraw, if one is already scheduled.

We want to support both synchronous and asynchronous scrolling.
Synchronous: we make sure that everything will be drawn before it gets
overwritten (cannot scroll more than one screen per refresh).
Asynchronous: process as many updates as possible between each
refresh, which occurs with a maximum rate equal to the display's
refresh rate.

** TODO

How does the vsync work?
EGL_KHR_wait_sync ?
