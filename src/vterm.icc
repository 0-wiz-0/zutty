/* -*- C++ -*-
 * This file is part of Zutty.
 * Copyright (C) 2020 Tom Szilagyi
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * See the file LICENSE for the full license.
 */

#include "pty.h"

#include <algorithm>
#include <iostream>

namespace {

   using namespace zutty;

   inline void
   unhandledInput (char ch, Vterm::InputState& state,
                   const uint8_t * chBegin, const uint8_t * chEnd)
   {
      std::cout << "Unhandled input char '" << ch << "' ("
                << (unsigned int)ch << ") in state " << (int)state
                << ". Escape sequence so far: '";
      for (auto it = chBegin; it != chEnd; ++it)
         std::cout << *it;
      std::cout << "'" << std::endl;

      state = Vterm::InputState::Normal;
   }

}

namespace zutty {

   inline void
   Vterm::readPty ()
   {
      ssize_t n = read (ptyFd, inputBuf, sizeof (inputBuf));
   #if 1
      std::cout << "read " << n << " bytes: ";
      for (int k = 0; k < n; ++k)
      {
         if (inputBuf[k] < ' ')
            std::cout << "<" << (unsigned int)inputBuf[k] << ">";
         else
            std::cout << inputBuf[k];
      }
      std::cout << std::endl;
   #endif
      int escBegin = 0;
      hideCursor ();
      for (int k = 0; k < n; ++k)
      {
         const char& ch = inputBuf [k];
         switch (inputState)
         {
         case InputState::Normal:
            switch (ch)
            {
            case '\e':
               inputState = InputState::Escape;
               inputOps [0] = 0;
               nInputOps = 1;
               escBegin = k + 1;
               break;
            case '\r': carriageReturn (); break;
            case '\n': esc_IND (); break;
            case '\b': csi_CUB (); break;
            case '\a':
               std::cout << "* Bell *" << std::endl;
               break;
            default:
            {
               auto& c = cell (cur);
               c = attrs;
               c.uc_pt = ch;
            }
            advancePosition ();
            }
            break;
         case InputState::Escape:
            switch (ch)
            {
            case '\e':
               inputState = InputState::Normal;
               break;
            case '[':
               inputState = InputState::CSI;
               break;
            case '(':
               attrs.bold = 0;
               inputState = InputState::Normal;
               break;
            case ')':
               attrs.bold = 1;
               inputState = InputState::Normal;
               break;
            case 'D': esc_IND (); break;
            case 'M': esc_RI (); break;
            case 'E': esc_NEL (); break;
            case '7': esc_DECSC (); break;
            case '8': esc_DECRC (); break;
            case '=':
               std::cout << "VT52 Enter alternate keypad mode" << std::endl;
               inputState = InputState::Normal;
               break;
            case '>':
               std::cout << "VT52 Exit alternate keypad mode" << std::endl;
               inputState = InputState::Normal;
               break;
            default:
               unhandledInput (ch, inputState,
                               inputBuf + escBegin, inputBuf + k + 1);
               break;
            }
            break;
         case InputState::CSI:
            switch (ch)
            {
            case '\e':
               inputState = InputState::Normal;
               break;
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
               inputOps [nInputOps - 1] *= 10;
               inputOps [nInputOps - 1] += ch - '0';
               break;
            case ';':
               if (nInputOps < maxEscOps)
                  inputOps [nInputOps ++] = 0;
               else
               {
                  std::cout << "inputOps full, increase maxEscOps (currently: "
                            << maxEscOps << ")!" << std::endl;
                  inputState = InputState::Normal;
               }
               break;
            case 'A': csi_CUU (); break;
            case 'B': csi_CUD (); break;
            case 'C': csi_CUF (); break;
            case 'D': csi_CUB (); break;
            case 'H': case 'f': csi_CUP (); break;
            case 'J': csi_ED (); break;
            case 'K': csi_EL (); break;
            case 'L': csi_IL (); break;
            case 'M': csi_DL (); break;
            case '@': csi_ICH (); break;
            case 'P': csi_DCH (); break;
            case 'h': csi_SM (); break;
            case 'l': csi_RM (); break;
            case 'm': csi_SGR (); break;
            case 'r': csi_STBM (); break;
            case '?':
               inputState = InputState::CSI_priv;
               break;
            default:
               unhandledInput (ch, inputState,
                               inputBuf + escBegin, inputBuf + k + 1);
               break;
            }
            break;
         case InputState::CSI_priv:
            switch (ch)
            {
            case '\e':
               inputState = InputState::Normal;
               break;
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
               inputOps [nInputOps - 1] *= 10;
               inputOps [nInputOps - 1] += ch - '0';
               break;
            case ';':
               if (nInputOps < maxEscOps)
                  inputOps [nInputOps ++] = 0;
               else
               {
                  std::cout << "inputOps full, increase maxEscOps (currently: "
                            << maxEscOps << ")!" << std::endl;
                  inputState = InputState::Normal;
               }
               break;
            case 'h': csipriv_SM (); break;
            case 'l': csipriv_RM (); break;
            default:
               unhandledInput (ch, inputState,
                               inputBuf + escBegin, inputBuf + k + 1);
               break;
            }
         }
      }
      showCursor ();
   }

   inline CharVdev::Cell &
   Vterm::cell (uint32_t idx)
   {
#if 1 /* strict / debug */
      if (idx >= nRows * nCols)
      {
         std::cout << "cell accessor: idx=" << idx
                   << " out of range, size=" << nRows * nCols
                   << std::endl;
         throw std::runtime_error ("cell accessor: index out of bounds");
      }
#endif
      return cells.get () [idx];
   }

   inline CharVdev::Cell &
   Vterm::cell (uint16_t row, uint16_t col)
   {
#if 1 /* strict / debug */
      if (row >= nRows || col >= nCols)
      {
         std::cout << "cell accessor: " << row << "," << col
                   << " out of range, size=" << nRows << "," << nCols
                   << std::endl;
         throw std::runtime_error ("cell accessor: index out of bounds");
      }
#endif
      uint32_t idx = (top + nCols * row + col) % (nRows * nCols);
      return cells.get () [idx];
   }

   inline uint32_t
   Vterm::setCur ()
   {
      cur = (top + nCols * posY + posX) % (nRows * nCols);
      return cur;
   }

   inline uint32_t
   Vterm::startOfThisLine ()
   {
      return cur - posX;
   }

   inline uint32_t
   Vterm::startOfNextLine ()
   {
      return cur - posX + nCols;
   }

   // start and end are physical indexes into cells
   inline void
   Vterm::eraseRange (uint32_t start, uint32_t end)
   {
      if (start < end)
         for (uint32_t k = start; k < end; ++k)
            cell (k) = attrs;
      else
      {
         for (uint32_t k = start; k < nRows * nCols; ++k)
            cell (k) = attrs;
         for (uint32_t k = 0; k < end; ++k)
            cell (k) = attrs;
      }
   }

   // start and count are logical line numbers [0..nRows)
   inline void
   Vterm::moveLines (uint16_t startY, uint16_t countY, int offset)
   {
      if (offset > 0) // move lines down -- work bottom up
      {
         for (uint16_t pY = startY + countY - 1; pY >= startY; --pY)
         {
            for (uint16_t pX = 0; pX < nCols; ++pX)
               cell (pY + offset, pX) = cell (pY, pX);
            if (!pY) break;
         }
         for (uint16_t pY = startY; pY < startY + offset; ++pY)
            for (uint16_t pX = 0; pX < nCols; ++pX)
               cell (pY, pX) = attrs;
      }
      else if (offset < 0) // push lines up -- work top down
      {
         for (uint16_t pY = startY; pY < startY + countY; ++pY)
            for (uint16_t pX = 0; pX < nCols; ++pX)
               cell (pY, pX) = cell (pY - offset, pX);
         for (uint16_t pY = startY + countY; pY < startY + countY + offset; ++pY)
            for (uint16_t pX = 0; pX < nCols; ++pX)
               cell (pY, pX) = attrs;
      }
   }

   inline void
   Vterm::lineFeed ()
   {
      esc_IND ();
      eraseRange (cur, startOfNextLine ());
   }

   inline void
   Vterm::carriageReturn ()
   {
      posX = 0;
      setCur ();
   }

   inline void
   Vterm::advancePosition ()
   {
      ++cur;
      ++posX;
      if (posX == nCols)
      {
         carriageReturn ();
         lineFeed ();
      }
   }

   inline void
   Vterm::showCursor ()
   {
      cell (cur).inverse = 1;
   }

   inline void
   Vterm::hideCursor ()
   {
      cell (cur).inverse = 0;
   }

   inline void
   Vterm::esc_IND ()
   {
      if (posY == nRows - 1)
      {
         top += nCols;
         top %= nRows * nCols;
         setCur ();
         if (top == 0)
            eraseRange ((nRows - 1) * nCols, nRows * nCols);
         else
            eraseRange (top - nCols, top);
      }
      else
      {
         ++posY;
         setCur ();
      }
      inputState = InputState::Normal;
   }

   inline void
   Vterm::esc_RI ()
   {
      if (posY > 0)
      {
         --posY;
         setCur ();
      }
      inputState = InputState::Normal;
   }

   inline void
   Vterm::esc_NEL ()
   {
      esc_IND ();
      posX = 0;
      cur = startOfThisLine ();
      inputState = InputState::Normal;
   }

   inline void
   Vterm::esc_DECSC ()
   {
      std::cout << "TODO DECSC" << std::endl;
      inputState = InputState::Normal;
   }

   inline void
   Vterm::esc_DECRC ()
   {
      std::cout << "TODO DECRC" << std::endl;
      inputState = InputState::Normal;
   }

   inline void
   Vterm::csi_SM ()
   {
      for (size_t k = 0; k < nInputOps; ++k)
      {
         const auto& arg = inputOps [k];

         switch (arg)
         {
         case 4:
            std::cout << "Insert/replace mode set to insert" << std::endl;
            break;
         default:
            std::cout << "set mode: unknown arg: " << arg << std::endl;
            break;
         }
      }
      inputState = InputState::Normal;
   }

   inline void
   Vterm::csi_RM ()
   {
      for (size_t k = 0; k < nInputOps; ++k)
      {
         const auto& arg = inputOps [k];

         switch (arg)
         {
         case 4:
            std::cout << "Insert/replace mode set to replace" << std::endl;
            break;
         default:
            std::cout << "reset mode: unknown arg: " << arg << std::endl;
            break;
         }
      }
      inputState = InputState::Normal;
   }

   inline void
   Vterm::csipriv_SM ()
   {
      for (size_t k = 0; k < nInputOps; ++k)
      {
         const auto& arg = inputOps [k];

         switch (arg)
         {
         case 1:
            std::cout << "Cursor keys send application control functions" << std::endl;
            break;
         case 25:
            std::cout << "Show cursor" << std::endl;
            break;
         case 1049:
            std::cout << "Enable alternative screen buffer" << std::endl;
            break;
         default:
            std::cout << "set mode priv: unknown arg: " << arg << std::endl;
            break;
         }
      }
      inputState = InputState::Normal;
   }

   inline void
   Vterm::csipriv_RM ()
   {
      for (size_t k = 0; k < nInputOps; ++k)
      {
         const auto& arg = inputOps [k];

         switch (arg)
         {
         case 1:
            std::cout << "Cursor keys generate ANSI cursor control sequences" << std::endl;
            break;
         case 25:
            std::cout << "Hide cursor" << std::endl;
            break;
         case 1049:
            std::cout << "Disable alternative screen buffer" << std::endl;
            break;
         default:
            std::cout << "reset mode priv: unknown arg: " << arg << std::endl;
            break;
         }
      }
      inputState = InputState::Normal;
   }

   inline void
   Vterm::csi_SGR ()
   {
      for (size_t k = 0; k < nInputOps; ++k)
      {
         const auto& attr = inputOps [k];

         switch (attr)
         {
         case 0:
            attrs.uc_pt = ' ';
            attrs.bold = 0;
            attrs.underline = 0;
            attrs.inverse = 0;
            attrs.fg = {255, 255, 255};
            attrs.bg = {0, 0, 0};
            break;
         case 1: attrs.bold = 1; break;
         case 2: attrs.bold = 0; break;
         case 3: attrs.inverse = 1; break; // italic
         case 4: attrs.underline = 1; break;
         case 7: attrs.inverse = 1; break;
         case 10: attrs.bold = 0; break;
         case 11: case 12: case 13: case 14: case 15:
         case 16: case 17: case 18: case 19: attrs.bold = 1; break;
         case 23: attrs.inverse = 0; break;
         case 24: attrs.underline = 0; break;
         case 27: attrs.inverse = 0; break;
         case 30: attrs.fg = {  0,   0,   0}; break;
         case 31: attrs.fg = {205,   0,   0}; break;
         case 32: attrs.fg = {  0, 205,   0}; break;
         case 33: attrs.fg = {205, 205,   0}; break;
         case 34: attrs.fg = {  0,   0, 238}; break;
         case 35: attrs.fg = {205,   0, 205}; break;
         case 36: attrs.fg = {  0, 205, 205}; break;
         case 37: attrs.fg = {229, 229, 229}; break;
         // TODO case 38: fgcolor based on multiple components
         case 39: attrs.fg = defaultFg; break;

         // bright colored foregrounds
         case 90: attrs.fg = {127, 127, 127}; break;
         case 91: attrs.fg = {255,   0,   0}; break;
         case 92: attrs.fg = {  0, 255,   0}; break;
         case 93: attrs.fg = {255, 255,   0}; break;
         case 94: attrs.fg = { 92,  92, 255}; break;
         case 95: attrs.fg = {255,   0, 255}; break;
         case 96: attrs.fg = {  0, 255, 255}; break;
         case 97: attrs.fg = {255, 255, 255}; break;

         case 40: attrs.bg = {  0,   0,   0}; break;
         case 41: attrs.bg = {205,   0,   0}; break;
         case 42: attrs.bg = {  0, 205,   0}; break;
         case 43: attrs.bg = {205, 205,   0}; break;
         case 44: attrs.bg = {  0,   0, 238}; break;
         case 45: attrs.bg = {205,   0, 205}; break;
         case 46: attrs.bg = {  0, 205, 205}; break;
         case 47: attrs.bg = {229, 229, 229}; break;
         // TODO case 48: bgcolor based on multiple components
         case 49: attrs.bg = defaultBg; break;

         // bright colored backgrounds
         case 100: attrs.bg = {127, 127, 127}; break;
         case 101: attrs.bg = {255,   0,   0}; break;
         case 102: attrs.bg = {  0, 255,   0}; break;
         case 103: attrs.bg = {255, 255,   0}; break;
         case 104: attrs.bg = { 92,  92, 255}; break;
         case 105: attrs.bg = {255,   0, 255}; break;
         case 106: attrs.bg = {  0, 255, 255}; break;
         case 107: attrs.bg = {255, 255, 255}; break;
         default:
            std::cout << "Unimplemented attribute: " << attr << std::endl;
            break;
         }
      }
      inputState = InputState::Normal;
   }

   inline void
   Vterm::csi_CUU ()
   {
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      arg = std::min (arg, posY);
      posY -= arg;
      setCur ();
      inputState = InputState::Normal;
   }

   inline void
   Vterm::csi_CUD ()
   {
      int arg = inputOps [0] ? inputOps [0] : 1;
      arg = std::min (arg, nRows - posY - 1);
      posY += arg;
      setCur ();
      inputState = InputState::Normal;
   }

   inline void
   Vterm::csi_CUF ()
   {
      int arg = inputOps [0] ? inputOps [0] : 1;
      arg = std::min (arg, nCols - posX - 1);
      posX += arg;
      setCur ();
      inputState = InputState::Normal;
   }

   inline void
   Vterm::csi_CUB ()
   {
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      arg = std::min (arg, posX);
      posX -= arg;
      setCur ();
      inputState = InputState::Normal;
   }

   inline void
   Vterm::csi_CUP ()
   {
      uint16_t row = inputOps [0] ? inputOps [0] : 1;
      uint16_t col = (nInputOps > 1 && inputOps [1]) ? inputOps [1] : 1;
      row = std::max ((uint16_t)1, std::min (row, nRows));
      col = std::max ((uint16_t)1, std::min (col, nCols));
      posX = col - 1;
      posY = row - 1;
      setCur ();
      inputState = InputState::Normal;
      std::cout << "Cursor positioned to (" << posY << "," << posX << ")"
                << std::endl;
   }

   inline void
   Vterm::csi_ED ()
   {
      uint32_t begin = cur;
      uint32_t end = cur + 1;
      switch (inputOps [0])
      {
      case 0: // clear from cursor to end of screen
         end = top;
         break;
      case 1: // clear from cursor to beginning of screen
         begin = top;
         break;
      case 2: // clear entire screen
         begin = top;
         end = top;
         break;
      default:
         std::cout << "Erase in Display with illegal param: "
                   << inputOps [0] << std::endl;
         break;
      }
      eraseRange (begin, end);
      inputState = InputState::Normal;
   }

   inline void
   Vterm::csi_EL ()
   {
      uint32_t begin = cur;
      uint32_t end = cur + 1;
      switch (inputOps [0])
      {
      case 0: // clear from cursor to end of line
         end = startOfNextLine ();
         break;
      case 1: // clear from cursor to beginning of line
         begin = startOfThisLine ();
         break;
      case 2: // clear entire line
         begin = startOfThisLine ();
         end = startOfNextLine ();
         break;
      default:
         std::cout << "Erase in Line with illegal param: "
                   << inputOps [0] << std::endl;
         break;
      }
      eraseRange (begin, end);
      inputState = InputState::Normal;
   }

   inline void
   Vterm::csi_IL ()
   {
      int arg = inputOps [0] ? inputOps [0] : 1;
      arg = std::min (arg, nRows - posY);
      moveLines (posY, nRows - posY - arg, arg);
      carriageReturn ();
      inputState = InputState::Normal;
   }

   inline void
   Vterm::csi_DL ()
   {
      int arg = inputOps [0] ? inputOps [0] : 1;
      arg = std::min (arg, nRows - posY);
      moveLines (posY + arg, nRows - posY - arg, -arg);
      carriageReturn ();
      inputState = InputState::Normal;
   }

   inline void
   Vterm::csi_ICH ()
   {
      uint32_t arg = inputOps [0] ? inputOps [0] : 1;
      uint32_t len = nCols - posX;
      arg = std::min (arg, len);
      len -= arg;
      memmove (cells.get () + cur + arg, cells.get () + cur,
               len * sizeof (CharVdev::Cell));
      eraseRange (cur, cur + arg);
      inputState = InputState::Normal;
   }

   inline void
   Vterm::csi_DCH ()
   {
      uint32_t arg = inputOps [0] ? inputOps [0] : 1;
      uint32_t len = nCols - posX - 1;
      memmove (cells.get () + cur, cells.get () + cur + arg,
               len * sizeof (CharVdev::Cell));
      eraseRange (cur + len, cur + len + arg);
      inputState = InputState::Normal;
   }

   inline void
   Vterm::csi_STBM ()
   {
      if ((nInputOps == 1 && inputOps [0] == 0) ||
          (nInputOps == 2 && inputOps [0] == 1 && inputOps [1] == nRows))
      {
         // no-op
         inputState = InputState::Normal;
         return;
      }

      // TODO this is unimplemented
      std::cout << "setScrollingMargins (";
      for (size_t k = 0; k < nInputOps; ++k)
         std::cout << inputOps [k] << " ";
      std::cout << "), nRows = " << nRows << std::endl;
      inputState = InputState::Normal;
   }


} // namespace zutty
