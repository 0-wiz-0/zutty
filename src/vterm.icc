/* -*- C++ -*-
 * This file is part of Zutty.
 * Copyright (C) 2020 Tom Szilagyi
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * See the file LICENSE for the full license.
 */

#include "pty.h"

#include <algorithm>
#include <iostream>
#include <sstream>

// for the debug/step facility:
#include <chrono>
#include <thread>
#include <sys/types.h>
#include <signal.h>

namespace {

   using namespace zutty;

#define LOG
//#define LOG_TRACE
//#define STEP_DEBUGGER

#ifdef LOG
   #define logE      std::cout << "Error: "
   #define logEcont  std::cout
   #define logU      std::cout << "(unimpl) "
   #define logUcont  std::cout
   #define logI      std::cout << "Info | "
#else
   #define logE      nullptr && std::cout
   #define logEcont  nullptr && std::cout
   #define logU      nullptr && std::cout
   #define logUcont  nullptr && std::cout
   #define logI      nullptr && std::cout
#endif

#ifdef LOG_TRACE
   #define logT      std::cout << "Trace | "
   #define logTcont  std::cout
   #define logP      std::cout << "-<pty>- "
   #define logPcont  std::cout
   #define TRACE_FUN                           \
      logT << __FUNCTION__ << " [";            \
      for (size_t k = 0; k < nInputOps; ++k) { \
         if (k) logTcont << ";";               \
         logTcont << inputOps [k];             \
      }                                        \
      logTcont << "]   \t"                     \
      << "p(" << posY << "," << posX           \
      << ")  d(" << nRows << "," << nCols      \
      << ")  mgn[" << cf->marginTop << "," << cf->marginBottom  \
      << ")  cur=" << cur                      \
      << "  head=" << cf->scrollHead           \
      << std::endl

#else
   #define logT      nullptr && std::cout
   #define logTcont  nullptr && std::cout
   #define logP      nullptr && std::cout
   #define logPcont  nullptr && std::cout
   #define TRACE_FUN
#endif

   inline int
   debugPrintInput (std::ostream & os,
                    unsigned char* start, unsigned char* end,
                    bool breakOnEsc = false)
   {
      int count = 0;
      os << "'";
      for (auto it = start; it != end; ++it)
      {
         if (breakOnEsc && *it == '\e')
            break;
         switch (*it)
         {
         case '\a': os << "\\a"; break;
         case '\b': os << "\\b"; break;
         case '\e': os << "\\e"; break;
         case '\f': os << "\\f"; break;
         case '\n': os << "\\n"; break;
         case '\r': os << "\\r"; break;
         case '\t': os << "\\t"; break;
         case '\v': os << "\\v"; break;
         case '\x7f': os << "<DEL>"; break;
         default:
            if (*it < ' ')
               os << "<" << (unsigned int)*it << ">";
            else
               os << *it;
            break;
         }
         ++count;
      }
      os << "' (" << count << " bytes)" << std::endl;
      return count;
   }

   // Dummy override for when log* streams are defined to nullptr
   inline int
   debugPrintInput (bool, unsigned char*, unsigned char*, bool = false)
   { return 0; }
}

namespace zutty {

#ifdef STEP_DEBUGGER
   #define DEBUGSTOP debugStop()

   inline void
   Vterm::debugStop ()
   {
      logT << "*** DEBUG STOP, "
           << readPos + 1 - lastStopPos << " bytes since last:\n        ";
      debugPrintInput (logTcont, inputBuf + lastStopPos, inputBuf + readPos + 1);
      lastStopPos = readPos + 1;

      logT << "Issue 'kill -CONT " << getpid () << "' or 'fg' to continue."
           << std::endl;

      redraw ();
      using namespace std::chrono_literals;
      std::this_thread::sleep_for (100ms);

      kill (getpid (), SIGSTOP);
   }
#else
   #define DEBUGSTOP
#endif // STEP_DEBUGGER

   inline void
   Vterm::unhandledInput (char ch)
   {
      logE << "Unhandled input char '" << ch
           << "' (" << (unsigned int)ch << ") in state " << (int)inputState
           << ". Escape sequence so far: ";
      debugPrintInput (logEcont, inputBuf + lastEscBegin, inputBuf + readPos + 1);
      setState (InputState::Normal);
   }

   inline void
   Vterm::traceNormalInput ()
   {
   #ifdef LOG_TRACE
      if (lastNormalBegin < readPos)
      {
         std::ostringstream oss;
         oss << "Inserted: ";
         if (debugPrintInput (oss, inputBuf + lastNormalBegin,
                              inputBuf + readPos, true))
            logT << oss.str ();
      }
      lastNormalBegin = readPos + 1;
   #endif
   }

   inline void
   Vterm::redraw ()
   {
      refreshVideo (* cf);
   }

   inline void
   Vterm::setHasFocus (bool hasFocus_)
   {
      hasFocus = hasFocus_;
      showCursor ();
      redraw ();
   }

   inline void
   Vterm::resetTerminal ()
   {
      resetScreen ();
      resetAttrs ();
      fillScreen (' ');

      switchColMode (ColMode::C80);

      cf->scrollHead = 0;
      cf->marginTop = 0;
      cf->marginBottom = nRows;
      cf->cursor.color = palette256 [defaultFgPalIx];
      posX = 0;
      posY = 0;
      setCur ();

      switchScreenBufferMode (false);

      setState (InputState::Normal);
   }

   inline void
   Vterm::resetScreen ()
   {
      showCursorMode = true;
      autoWrapMode = true;
      autoNewlineMode = false;
      insertMode = false;
      bkspSendsDel = true;
      localEcho = false;

      compatLevel = CompatibilityLevel::VT400;
      cursorKeyMode = CursorKeyMode::ANSI;
      keypadMode = KeypadMode::Normal;
      originMode = OriginMode::Absolute;
      charsetState = CharsetState {};

      savedCursor_SCO.isSet = false;
      savedCursor_DEC->isSet = false;

      tabStops.clear ();
   }

   inline void
   Vterm::resetAttrs ()
   {
      reverseVideo = false;
      fg = &attrs.fg;
      bg = &attrs.bg;

      inputOps [0] = 0;
      nInputOps = 1;
      csi_SGR ();
   }

   inline void
   Vterm::clearScreen ()
   {
      posX = 0;
      posY = 0;
      setCur ();
      fillScreen (' ');
   }

   inline void
   Vterm::fillScreen (uint16_t ch)
   {
      for (uint32_t k = 0; k < nRows * nCols; ++k)
      {
         (* cf) [k] = attrs;
         (* cf) [k].uc_pt = ch;
      }
   }

   inline void
   Vterm::switchColMode (ColMode colMode_)
   {
      if (colMode == colMode_)
         return;

      resetScreen ();
      clearScreen ();

      if (colMode_ == ColMode::C80)
      {
         logT << "DECCOLM: Selected 80 columns per line" << std::endl;
      }
      else
      {
         logT << "DECCOLM: Selected 132 columns per line" << std::endl;
      }

      colMode = colMode_;
   }

   inline void
   Vterm::switchScreenBufferMode (bool altScreenBufferMode_)
   {
      if (altScreenBufferMode == altScreenBufferMode_)
         return;

      if (altScreenBufferMode_)
      {
         frame_alt = Frame (winPx, winPy, nCols, nRows);
         cf = &frame_alt;

         savedCursor_DEC = &savedCursor_DEC_alt;
         altScreenBufferMode = true;

         resetScreen ();
      }
      else
      {
         frame_pri.resize (winPx, winPy, nCols, nRows);
         cf = &frame_pri;
         frame_alt.freeCells ();

         savedCursor_DEC_alt.isSet = false;
         savedCursor_DEC = &savedCursor_DEC_pri;
         altScreenBufferMode = false;
      }
   }

   inline void
   Vterm::setState (InputState newState)
   {
      if (newState == inputState)
         return;

      if (newState == InputState::Normal)
      {
         DEBUGSTOP;
         nInputOps = 0;
         inputOps [0] = 0;
         lastNormalBegin = readPos + 1;
      }
      else
      {
         traceNormalInput ();
      }

      inputState = newState;
   }

   inline int
   Vterm::writePty (uint8_t ch, VtModifier modifiers)
   {
      logP << "write (mod=" << (int)modifiers << "): ";
      auto uch = (unsigned char*)&ch;
      debugPrintInput (logPcont, uch, uch + 1);
      if ((modifiers & VtModifier::alt) != VtModifier::none)
      {
         static uint8_t wbuf [2] = { '\e', '\0' };
         wbuf [1] = ch;
         if (localEcho)
         {
            static uint8_t pbuf [4] = { '^', '[', '\0', '\0' };
            uint8_t k = 3;
            if (ch >= ' ')
               pbuf [2] = ch;
            else
            {
               pbuf [2] = '^';
               pbuf [3] = ch + 0x40;
               k = 4;
            }
            logP << "pbuf: ";
            debugPrintInput (logPcont, pbuf, pbuf + k);
            processInput (pbuf, k);
         }
         return write (ptyFd, wbuf, 2);
      }
      else
      {
         if (localEcho)
            processInput (uch, 1);
         return write (ptyFd, &ch, 1);
      }
   }

   inline int
   Vterm::writePty (const char* cstr)
   {
      logP << "write: ";
      auto ucstr = (unsigned char*)cstr;
      debugPrintInput (logPcont, ucstr, ucstr + strlen (cstr));
      if (localEcho)
         processInput (ucstr, strlen (cstr));
      return write (ptyFd, cstr, strlen (cstr));
   }

   inline void
   Vterm::readPty ()
   {
      ssize_t n = read (ptyFd, inputBuf, sizeof (inputBuf));

      logP << "read: ";
      debugPrintInput (logPcont, inputBuf, inputBuf + n);
      processInput (inputBuf, n);
   }

   inline uint32_t
   Vterm::setCur ()
   {
      cur = cf->getIdx (posY, posX);
      return cur;
   }

   inline void
   Vterm::normalizeCursorPos ()
   {
      if (nCols < posX + 1)
         posX = nCols - 1;

      if (nRows < posY + 1)
         posY = nRows - 1;

      setCur ();
   }

   inline uint32_t
   Vterm::startOfThisLine ()
   {
      return cur - posX;
   }

   inline uint32_t
   Vterm::startOfNextLine ()
   {
      return cur - posX + nCols;
   }

   // N.B.: Only use this to erase (within) one line.
   // Use a series of eraseRow () calls to erase larger areas!
   inline void
   Vterm::eraseRange (uint32_t start, uint32_t end)
   {
      for (uint32_t k = start; k < end; ++k)
         (* cf) [k] = attrs;
   }

   inline void
   Vterm::eraseRow (uint16_t pY)
   {
      uint32_t idx = cf->getIdx (pY, 0);
      eraseRange (idx, idx + nCols);
   }

   inline void
   Vterm::copyRow (uint16_t dstY, uint16_t srcY)
   {
      uint32_t dstIdx = cf->getIdx (dstY, 0);
      uint32_t srcIdx = cf->getIdx (srcY, 0);
      cf->copyCells (dstIdx, srcIdx, nCols);
   }

   // insert lines at and below posY, within the scrolling area
   inline void
   Vterm::insertLines (uint16_t count)
   {
      logT << "insertLines: count=" << count << std::endl;

      for (uint16_t pY = cf->marginBottom - count - 1; pY >= posY; --pY)
      {
         copyRow (pY + count, pY);
         if (!pY) break;
      }

      for (uint16_t pY = posY; pY < posY + count; ++pY)
         eraseRow (pY);
   }

   // delete lines at and below posY, within the scrolling area
   inline void
   Vterm::deleteLines (uint16_t count)
   {
      logT << "deleteLines: count=" << count << std::endl;

      for (uint16_t pY = posY; pY < cf->marginBottom - count; ++pY)
         copyRow (pY, pY + count);

      for (uint16_t pY = cf->marginBottom - count; pY < cf->marginBottom; ++pY)
         eraseRow (pY);
   }

   inline void
   Vterm::utf8_check_premature_EOS ()
   {
      if (utf8_rem > 0)
      {
         utf8_rem = 0;
         utf8_valid = false;
         placeGraphicChar ();
      }
   }

   inline void
   Vterm::inputGraphicChar (unsigned char ch)
   {
      if ((ch & 0x80) == 0)
      {
         utf8_check_premature_EOS ();

         // GL range
         Charset cs;
         if (charsetState.ss)
         {
            cs = charsetState.g [charsetState.ss];
            charsetState.ss = 0;
         }
         else
            cs = charsetState.g [charsetState.gl];

         if (cs == Charset::UTF8)
            unicode_cp = ch < 127 ? ch : 0;
         else if (ch >= 32 && (cs == Charset::IsoLatin1 || ch < 127))
            unicode_cp = charCodes [(uint8_t)cs - 1] [ch - 32];
         else
            unicode_cp = 0;

         if (unicode_cp)
         {
            utf8_valid = true;
            placeGraphicChar ();
         }
      }
      else
      {
         // GR range
         Charset cs = charsetState.g [charsetState.gr];
         if (cs == Charset::UTF8)
         {
            if ((ch >> 6) == 0x2) // 10xx'xxxx
            {
               logT << "utf-8 sequence cont, utf8_rem=" << (int)utf8_rem
                    << " utf8_valid=" << utf8_valid << std::endl;
               if (utf8_rem > 0)
               {
                  if (utf8_rem > 1 && (!ch || (unicode_cp == 0 && ch < 0xa0)))
                     utf8_valid = false; // reject overlong encodings
                  unicode_cp <<= 6;
                  unicode_cp += ch & 0x3f;
                  --utf8_rem;
               }
               else
                  utf8_valid = false; // unexpected UTF-8 continuation byte

               if (utf8_rem == 0)
                  placeGraphicChar ();
            }
            else if ((ch >> 5) == 0x6) // 110x'xxxx
            {
               utf8_check_premature_EOS ();
               logT << "utf-8 2-byte sequence" << std::endl;
               unicode_cp = ch & 0x1f;
               utf8_rem = 1;
               utf8_valid = unicode_cp > 1; // reject overlong encodings
            }
            else if ((ch >> 4) == 0xe) // 1110'xxxx
            {
               utf8_check_premature_EOS ();
               logT << "utf-8 3-byte sequence" << std::endl;
               unicode_cp = ch & 0x0f;
               utf8_rem = 2;
               utf8_valid = true;
            }
            else if ((ch >> 3) == 0x1e) // 1111'0xxx
            {
               utf8_check_premature_EOS ();
               logT << "utf-8 4-byte sequence" << std::endl;
               unicode_cp = ch & 0x07;
               utf8_rem = 3;
               utf8_valid = false; // not supported
            }
            else if ((ch >> 2) == 0x3e) // 1111'10xx
            {
               utf8_check_premature_EOS ();
               logT << "utf-8 5-byte sequence" << std::endl;
               unicode_cp = ch & 0x03;
               utf8_rem = 4;
               utf8_valid = false; // not supported
            }
            else if ((ch >> 1) == 0x7e) // 1111'110x
            {
               utf8_check_premature_EOS ();
               logT << "utf-8 6-byte sequence" << std::endl;
               unicode_cp = ch & 0x01;
               utf8_rem = 5;
               utf8_valid = false; // not supported
            }
            else if (ch == 0xfe || ch == 0xff)
            {
               // illegal UTF-8 characters
               utf8_valid = false;
               placeGraphicChar ();
            }
         }
         else
         {
            if (ch >= 160 && (cs == Charset::IsoLatin1 || ch < 255))
               unicode_cp = charCodes [(uint8_t)cs - 1] [ch - 160];
            else
               unicode_cp = 0;

            if (unicode_cp)
            {
               utf8_valid = true;
               placeGraphicChar ();
            }
         }
      }
   }

   inline void
   Vterm::placeGraphicChar ()
   {
      if (! autoWrapMode && posX == nCols)
         return;

      if (posX == nCols)
      {
         inp_CR ();
         inp_LF ();
      }

      if (insertMode)
      {
         nInputOps = 1;
         inputOps [0] = 1;
         csi_ICH ();
      }

      auto& c = (* cf) [cur];
      c = attrs;
      c.uc_pt = utf8_valid ? unicode_cp : Unicode_Replacement_Character;
      advancePosition ();
    }

   inline void
   Vterm::inp_LF ()
   {
      TRACE_FUN;
      if (esc_IND ())
         eraseRange (cur, startOfNextLine ());
   }

   inline void
   Vterm::inp_CR ()
   {
      TRACE_FUN;
      posX = 0;
      setCur ();
   }

   inline void
   Vterm::jumpToNextTabStop ()
   {
      if (tabStops.empty ())
      {
         // Hard default of 8 chars limited to right margin
         posX = std::min(((posX / 8) + 1) * 8, nCols - 1);
      }
      else
      {
         // Next tabstop column set, or the right margin
         auto ts = std::lower_bound (tabStops.begin (), tabStops.end (), posX);
         posX = (ts == tabStops.end ()) ? nCols - 1 : * ts;
      }
      setCur ();
   }

   inline void
   Vterm::inp_HT ()
   {
      TRACE_FUN;
      if (posX == nCols)
      {
         inp_CR ();
         esc_IND ();
      }
      else
         jumpToNextTabStop ();
   }

   inline void
   Vterm::advancePosition ()
   {
      ++posX;
      setCur ();
   }

   inline void
   Vterm::showCursor ()
   {
      TRACE_FUN;
      if (showCursorMode)
      {
         cf->cursor.posX = posX;
         cf->cursor.posY = posY;
         using CS = CharVdev::Cursor::Style;
         cf->cursor.style = hasFocus ? CS::filled_block : CS::hollow_block;
      }
   }

   inline void
   Vterm::hideCursor ()
   {
      TRACE_FUN;
      using CS = CharVdev::Cursor::Style;
      cf->cursor.style = CS::hidden;
   }

   inline void
   Vterm::esc_DCS (unsigned char fin)
   {
      TRACE_FUN;

      logT << "Designate Character Set: destination '" << scsDst
           <<"', charset '";
      if (scsMod)
         logTcont << scsMod;
      logTcont << fin << "'" << std::endl;

      uint8_t ix = 0;
      bool cs96 = false;
      switch (scsDst)
      {
      case '(': ix = 0; break;
      case ')': ix = 1; break;
      case '*': ix = 2; break;
      case '+': ix = 3; break;
      case '-': ix = 1; cs96 = true; break;
      case '.': ix = 2; cs96 = true; break;
      case '/': ix = 3; cs96 = true; break;
      }

      Charset cs = Charset::UTF8;
      switch (fin)
      {
      case 'A': cs = cs96 ? Charset::IsoLatin1 : Charset::IsoUK; break;
      case 'B': cs = Charset::UTF8; break;
      case '0': cs = Charset::DecSpec; break;
      case '5':
         if (scsMod == '%')
            cs = Charset::DecSuppl;
         break;
      case '<': cs = Charset::DecUserPref; break;
      case '>': cs = Charset::DecTechn; break;
      }

      charsetState.g [ix] = cs;
      setState (InputState::Normal);
   }

   inline bool
   Vterm::esc_IND ()
   {
      TRACE_FUN;
      bool scrolled = false;
      if (posY == cf->marginBottom - 1)
      {
         nInputOps = 1;
         inputOps [0] = 1;
         csi_SU ();
         scrolled = true;
      }
      else if (posY < nRows - 1)
      {
         ++posY;
         setCur ();
      }
      setState (InputState::Normal);
      return scrolled;
   }

   inline void
   Vterm::esc_RI ()
   {
      TRACE_FUN;
      if (posY == cf->marginTop)
      {
         nInputOps = 1;
         inputOps [0] = 1;
         csi_SD ();
      }
      else if (posY > 0)
      {
         --posY;
         setCur ();
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_ecma48_SL ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1u;
      arg = std::min (arg, nCols);
      // move all lines within scrolling area to the left by arg positions:
      for (uint16_t r = cf->marginTop; r < cf->marginBottom; ++r)
      {
         cf->moveCells (nCols * r, nCols * r + arg, nCols - arg);
         eraseRange (nCols * (r + 1) - arg, nCols * (r + 1));
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_ecma48_SR ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1u;
      arg = std::min (arg, nCols);
      // move all lines within scrolling area to the right by arg positions:
      for (uint16_t r = cf->marginTop; r < cf->marginBottom; ++r)
      {
         cf->moveCells (nCols * r + arg, nCols * r, nCols - arg);
         eraseRange (nCols * r, nCols * r + arg);
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::esc_FI ()
   {
      TRACE_FUN;
      nInputOps = 1;
      inputOps [0] = 1;
      if (posX < nCols - 1)
         csi_CUF ();
      else
         csi_ecma48_SL ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::esc_BI ()
   {
      TRACE_FUN;
      nInputOps = 1;
      inputOps [0] = 1;
      if (posX > 0)
         csi_CUB ();
      else
         csi_ecma48_SR ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::esc_NEL ()
   {
      TRACE_FUN;
      esc_IND ();
      posX = 0;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::esc_HTS ()
   {
      TRACE_FUN;
      tabStops.push_back (posX);
      std::sort (tabStops.begin (), tabStops.end ());
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_SCOSC ()
   {
      TRACE_FUN;
      savedCursor_SCO.posX = posX;
      savedCursor_SCO.posY = posY;
      savedCursor_SCO.isSet = true;
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_SCORC ()
   {
      TRACE_FUN;
      if (!savedCursor_SCO.isSet)
      {
         logI << "Asked to restore cursor (SCORC) but it has not been saved."
              << std::endl;
      }
      else
      {
         posX = savedCursor_SCO.posX;
         posY = savedCursor_SCO.posY;
         normalizeCursorPos ();
         savedCursor_SCO.isSet = false;
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::esc_DECSC ()
   {
      TRACE_FUN;
      savedCursor_DEC->posX = posX;
      savedCursor_DEC->posY = posY;
      savedCursor_DEC->attrs = attrs;
      savedCursor_DEC->autoWrapMode = autoWrapMode;
      savedCursor_DEC->originMode = originMode;
      savedCursor_DEC->charsetState = charsetState;
      savedCursor_DEC->isSet = true;
      setState (InputState::Normal);
   }

   inline void
   Vterm::esc_DECRC ()
   {
      TRACE_FUN;
      if (!savedCursor_DEC->isSet)
      {
         logI << "Asked to restore cursor (DECRC) but it has not been saved."
              << std::endl;
      }
      else
      {
         posX = savedCursor_DEC->posX;
         posY = savedCursor_DEC->posY;
         normalizeCursorPos ();
         attrs = savedCursor_DEC->attrs;
         autoWrapMode = savedCursor_DEC->autoWrapMode;
         originMode = savedCursor_DEC->originMode;
         charsetState = savedCursor_DEC->charsetState;
         savedCursor_DEC->isSet = false;
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CUU ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      if (posY >= cf->marginTop)
         arg = std::min ((int)arg, posY - cf->marginTop);
      else
         arg = std::min (arg, posY);
      posY -= arg;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CUD ()
   {
      TRACE_FUN;
      int arg = inputOps [0] ? inputOps [0] : 1;
      if (posY < cf->marginBottom)
         arg = std::min (arg, cf->marginBottom - posY - 1);
      else
         arg = std::min (arg, nRows - posY - 1);
      posY += arg;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CUF ()
   {
      TRACE_FUN;
      int arg = inputOps [0] ? inputOps [0] : 1;
      arg = std::min (arg, nCols - posX - 1);
      posX += arg;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CUB ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      arg = std::min (arg, posX);
      if (posX == nCols)
         arg = std::min (arg + 1, (int)posX);
      posX -= arg;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CNL ()
   {
      TRACE_FUN;
      csi_CUD ();
      inp_CR ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CPL ()
   {
      TRACE_FUN;
      csi_CUU ();
      inp_CR ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CHA ()
   {
      TRACE_FUN;
      uint16_t col = inputOps [0] ? inputOps [0] : 1;
      col = std::max ((uint16_t)1, std::min (col, nCols));
      posX = col - 1;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_HPA ()
   {
      TRACE_FUN;
      csi_CHA ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_HPR ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      inputOps [0] = posX + arg + 1;
      csi_CHA ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_VPA ()
   {
      TRACE_FUN;
      uint16_t row = inputOps [0] ? inputOps [0] : 1;
      row = std::max ((uint16_t)1, std::min (row, nRows));
      posY = row - 1;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_VPR ()
   {
      TRACE_FUN;
      uint16_t row = inputOps [0] ? inputOps [0] : 1;
      row += (posY + 1);
      row = std::max ((uint16_t)1, std::min (row, nRows));
      posY = row - 1;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CUP ()
   {
      TRACE_FUN;
      uint16_t row = inputOps [0] ? inputOps [0] : 1;
      uint16_t col = (nInputOps > 1 && inputOps [1]) ? inputOps [1] : 1;
      switch (originMode)
      {
      case OriginMode::Absolute:
         row = std::max ((uint16_t)1, std::min (row, nRows)) - 1;
         break;
      case OriginMode::ScrollingRegion:
         row = std::max ((uint16_t)1, std::min (row, cf->marginBottom)) - 1;
         row += cf->marginTop;
         break;
      }
      col = std::max ((uint16_t)1, std::min (col, nCols)) - 1;

      posX = col;
      posY = row;
      setCur ();
      setState (InputState::Normal);
      logT << "Cursor positioned to (" << posY << "," << posX << ")"
           << std::endl;
   }

   inline void
   Vterm::csi_SU ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      for (uint16_t k = 0; k < arg; ++k)
      {
         cf->scrollHead += nCols;
         if (cf->scrollHead == cf->marginBottom * nCols)
         {
            cf->scrollHead = cf->marginTop * nCols;
            eraseRange ((cf->marginBottom - 1) * nCols, cf->marginBottom * nCols);
         }
         else
         {
            eraseRange (cf->scrollHead - nCols, cf->scrollHead);
         }
      }
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_SD ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      for (uint16_t k = 0; k < arg; ++k)
      {
         if (cf->scrollHead >= (cf->marginTop + 1u) * nCols)
            cf->scrollHead -= nCols;
         else
            cf->scrollHead = (cf->marginBottom - 1u) * nCols;
         eraseRange (cf->scrollHead, cf->scrollHead + nCols);
      }
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CHT ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      if (arg == 1)
         inp_HT ();
      else
         for (int k = 0; k < arg; ++k)
            jumpToNextTabStop ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CBT ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      for (uint16_t k = 0; k < arg; ++k)
      {
         if (tabStops.empty ())
         {
            if (posX > 0 && posX % 8 == 0)
               posX -= 8;
            else
               posX = (posX / 8) * 8;
         }
         else
         {
            // Set posX to previous tab stop
            auto ts = std::lower_bound (tabStops.begin (), tabStops.end (), posX);
            if (ts != tabStops.begin ())
               posX = * (--ts);
            else
               posX = 0;
         }
         setCur ();
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_REP ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      for (int k = 0; k < arg; ++k)
         placeGraphicChar ();
      unicode_cp = ' ';
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_ED ()
   {
      TRACE_FUN;
      switch (inputOps [0])
      {
      case 0: // clear from cursor to end of screen
         eraseRange (cur, startOfNextLine ());
         for (uint16_t pY = posY + 1; pY < nRows; ++pY)
            eraseRow (pY);
         break;
      case 1: // clear from beginning of screen to cursor
         for (uint16_t pY = 0; pY < posY; ++pY)
            eraseRow (pY);
         eraseRange (startOfThisLine (), cur + 1);
         break;
      case 2: // clear entire screen
         for (uint16_t pY = 0; pY < nRows; ++pY)
            eraseRow (pY);
         break;
      default:
         logI << "Erase in Display with illegal param: "
              << inputOps [0] << std::endl;
         break;
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_EL ()
   {
      TRACE_FUN;
      uint32_t begin = cur;
      uint32_t end = cur + 1;
      switch (inputOps [0])
      {
      case 0: // clear from cursor to end of line
         end = startOfNextLine ();
         break;
      case 1: // clear from cursor to beginning of line
         begin = startOfThisLine ();
         break;
      case 2: // clear entire line
         begin = startOfThisLine ();
         end = startOfNextLine ();
         break;
      default:
         logI << "Erase in Line with illegal param: "
              << inputOps [0] << std::endl;
         break;
      }
      eraseRange (begin, end);
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_IL ()
   {
      TRACE_FUN;
      if (posY < cf->marginTop || posY >= cf->marginBottom)
      {
         setState (InputState::Normal);
         return;
      }
      int arg = inputOps [0] ? inputOps [0] : 1;
      arg = std::min (arg, cf->marginBottom - posY);
      insertLines (arg);
      inp_CR ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_DL ()
   {
      TRACE_FUN;
      if (posY < cf->marginTop || posY >= cf->marginBottom)
      {
         setState (InputState::Normal);
         return;
      }
      int arg = inputOps [0] ? inputOps [0] : 1;
      arg = std::min (arg, cf->marginBottom - posY);
      deleteLines (arg);
      inp_CR ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_ICH ()
   {
      TRACE_FUN;
      uint32_t arg = inputOps [0] ? inputOps [0] : 1;
      uint32_t len = nCols - posX;
      arg = std::min (arg, len);
      len -= arg;
      cf->moveCells (cur + arg, cur, len);
      eraseRange (cur, cur + arg);
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_DCH ()
   {
      TRACE_FUN;
      uint32_t arg = inputOps [0] ? inputOps [0] : 1;
      uint32_t len = nCols - posX;
      arg = std::min (arg, len);
      len -= arg;
      cf->moveCells (cur, cur + arg, len);
      eraseRange (cur + len, cur + len + arg);
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_ECH ()
   {
      TRACE_FUN;
      uint32_t arg = inputOps [0] ? inputOps [0] : 1;
      uint32_t len = nCols - posX;
      arg = std::min (arg, len);
      eraseRange (cur, cur + arg);
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_STBM ()
   {
      TRACE_FUN;
      if (nInputOps == 1 && inputOps [0] == 0)
      {
         if (cf->marginTop != 0 || cf->marginBottom != nRows)
         {
            cf->linearizeCellStorage ();
            cf->marginTop = 0;
            cf->marginBottom = nRows;
            cf->scrollHead = 0;
         }
      }
      else if (nInputOps == 2)
      {
         uint16_t newMarginTop = inputOps [0] > 0 ? inputOps [0] - 1 : 0;
         uint16_t newMarginBottom = inputOps [1];

         if (newMarginBottom < newMarginTop + 2 || nRows < newMarginBottom)
         {
            logI << "Illegal arguments to SetTopBottomMargins: top="
                 << inputOps [0] << ", bottom=" << inputOps [1] << std::endl;
         }
         else if (newMarginTop != cf->marginTop || newMarginBottom != cf->marginBottom)
         {
            cf->linearizeCellStorage ();
            cf->marginTop = newMarginTop;
            cf->marginBottom = newMarginBottom;
            cf->scrollHead = cf->marginTop * nCols;
         }
      }

      posX = 0;
      posY = cf->marginTop;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_TBC ()
   {
      TRACE_FUN;
      switch (inputOps [0])
      {
      case 0:
      {
         auto it = std::find (tabStops.begin (), tabStops.end (), posX);
         if (it != tabStops.end ())
            tabStops.erase (it);
      }
         break;
      case 3:
         tabStops.clear ();
         break;
      default:
         break;
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_SM ()
   {
      TRACE_FUN;
      for (size_t k = 0; k < nInputOps; ++k)
      {
         const auto& arg = inputOps [k];

         switch (arg)
         {
         case 4: insertMode = true; break;
         case 12: localEcho = false; break;
         case 20: autoNewlineMode = true; break;
         default:
            logU << "set mode " << arg << std::endl;
            break;
         }
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_RM ()
   {
      TRACE_FUN;
      for (size_t k = 0; k < nInputOps; ++k)
      {
         const auto& arg = inputOps [k];

         switch (arg)
         {
         case 4: insertMode = false; break;
         case 12: localEcho = true; break;
         case 20: autoNewlineMode = false; break;
         default:
            logU << "reset mode " << arg << std::endl;
            break;
         }
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_privSM ()
   {
      TRACE_FUN;
      for (size_t k = 0; k < nInputOps; ++k)
      {
         const auto& arg = inputOps [k];

         switch (arg)
         {
         case 1: cursorKeyMode = CursorKeyMode::Application; break;
         case 2:
            charsetState = CharsetState {};
            compatLevel = CompatibilityLevel::VT400;
            break;
         case 3: switchColMode (ColMode::C132); break;
         case 4:
            logT << "DECSCLM: Selected smooth scroll" << std::endl;
            break;
         case 5:
            logU << "DECSCNM: Selected inverse video mode" << std::endl;
            break;
         case 6: originMode = OriginMode::ScrollingRegion; break;
         case 7: autoWrapMode = true; break;
         case 8:
            logU << "DECARM: Auto-repeat mode enabled" << std::endl;
            break;
         case 12:
            logU << "Start blinking cursor" << std::endl;
            break;
         case 25: showCursorMode = true; break;
         case 47: switchScreenBufferMode (true);  break;
         case 67: bkspSendsDel = false; break;
         case 1000:
            logU << "Enable mouse tracking mode" << std::endl;
            break;
         case 1047: switchScreenBufferMode (true); break;
         case 1048: esc_DECSC (); break;
         case 1049: esc_DECSC (); switchScreenBufferMode (true); break;
         default:
            logU << "set priv mode " << arg << std::endl;
            break;
         }
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_privRM ()
   {
      TRACE_FUN;
      for (size_t k = 0; k < nInputOps; ++k)
      {
         const auto& arg = inputOps [k];

         switch (arg)
         {
         case 1: cursorKeyMode = CursorKeyMode::ANSI; break;
         case 2:
            charsetState = CharsetState {};
            compatLevel = CompatibilityLevel::VT52;
            break;
         case 3: switchColMode (ColMode::C80); break;
         case 4:
            logT << "DECSCLM: Selected jump scroll" << std::endl;
            break;
         case 5:
            logU << "DECSCNM: Selected normal video mode" << std::endl;
            break;
         case 6: originMode = OriginMode::Absolute; break;
         case 7: autoWrapMode = false; break;
         case 8:
            logU << "DECARM: Auto-repeat mode disabled" << std::endl;
            break;
         case 12:
            logU << "Stop blinking cursor" << std::endl;
            break;
         case 25: showCursorMode = false; break;
         case 47: switchScreenBufferMode (false); break;
         case 67: bkspSendsDel = true; break;
         case 1000:
            logU << "Disable mouse tracking mode" << std::endl;
            break;
         case 1047: switchScreenBufferMode (false); break;
         case 1048: esc_DECRC (); break;
         case 1049: switchScreenBufferMode (false); esc_DECRC (); break;
         default:
            logU << "reset priv mode " << arg << std::endl;
            break;
         }
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::setFgFromPalIx ()
   {
      if (attrs.bold && fgPalIx >= 0 && fgPalIx <= 7)
         *fg = palette256 [fgPalIx + 8];
      else
         *fg = palette256 [fgPalIx];
   }

   inline void
   Vterm::setBgFromPalIx ()
   {
      *bg = palette256 [bgPalIx];
   }

   inline void
   Vterm::csi_SGR ()
   {
      TRACE_FUN;
      for (size_t k = 0; k < nInputOps; ++k)
      {
         const auto& attr = inputOps [k];

         switch (attr)
         {
         case 0:
            attrs.uc_pt = ' ';
            attrs.bold = 0;
            attrs.underline = 0;
            attrs.inverse = 0;
            reverseVideo = false;
            fg = &attrs.fg;
            bg = &attrs.bg;
            fgPalIx = defaultFgPalIx;
            setFgFromPalIx ();
            bgPalIx = defaultBgPalIx;
            setBgFromPalIx ();
            break;
         case 1: attrs.bold = 1; setFgFromPalIx (); break;
         case 2: attrs.bold = 0; setFgFromPalIx (); break;
         case 3: /* italic on */ break;
         case 4: attrs.underline = 1; break;
         case 5: /* blink on */ break;
         case 7:
            if (!reverseVideo)
            {
               fg = &attrs.bg;
               bg = &attrs.fg;
               reverseVideo = true;
               setFgFromPalIx ();
               setBgFromPalIx ();
            }
            break;
         case 8: logU << "attr.: concealed" << std::endl; break;
         case 10: attrs.bold = 0;  setFgFromPalIx (); break;
         case 11: case 12: case 13: case 14: case 15:
         case 16: case 17: case 18: case 19:
            attrs.bold = 1;  setFgFromPalIx ();
            break;
         case 22: attrs.bold = 0; setFgFromPalIx (); break;
         case 23: /* italic off */ break;
         case 25: /* blink off */ break;
         case 24: attrs.underline = 0; break;
         case 27:
            if (reverseVideo)
            {
               fg = &attrs.fg;
               bg = &attrs.bg;
               reverseVideo = false;
               setFgFromPalIx ();
               setBgFromPalIx ();
            }
            break;
         case 28: logU << "attr.: revealed (conceal off)" << std::endl; break;

         // standard foregrounds (bright if bold)
         case 30: case 31: case 32: case 33: case 34: case 35: case 36: case 37:
            fgPalIx = attr - 30;
            setFgFromPalIx ();
            break;

         case 38:
            if (k >= nInputOps - 1) break;
            switch (inputOps [++k])
            {
            case 5:
               if (k >= nInputOps - 1) break;
               fgPalIx = inputOps [++k];
               setFgFromPalIx ();
               break;
            case 2:
               if (k >= nInputOps - 3) break;
               (*fg).red   = inputOps [++k];
               (*fg).green = inputOps [++k];
               (*fg).blue  = inputOps [++k];
               break;
            default:
               break;
            }
            break;
         case 39: fgPalIx = defaultFgPalIx; setFgFromPalIx (); break;

         // standard backgrounds
         case 40: case 41: case 42: case 43: case 44: case 45: case 46: case 47:
            bgPalIx = attr - 40;
            setBgFromPalIx ();
            break;

         case 48:
            if (k >= nInputOps - 1) break;
            switch (inputOps [++k])
            {
            case 5:
               if (k >= nInputOps - 1) break;
               bgPalIx = inputOps [++k];
               setBgFromPalIx ();
               break;
            case 2:
               if (k >= nInputOps - 3) break;
               (*bg).red   = inputOps [++k];
               (*bg).green = inputOps [++k];
               (*bg).blue  = inputOps [++k];
               break;
            default:
               break;
            }
            break;
         case 49: bgPalIx = defaultBgPalIx; setBgFromPalIx (); break;

         // bright colored foregrounds
         case 90: case 91: case 92: case 93: case 94: case 95: case 96: case 97:
            fgPalIx = attr - 82;
            setFgFromPalIx ();
            break;

         // bright colored backgrounds
         case 100: case 101: case 102: case 103: case 104: case 105: case 106:
         case 107:
            bgPalIx = attr - 92;
            setBgFromPalIx ();
            break;

         default:
            logU << "attribute: " << attr << std::endl;
            break;
         }
      }
      setState (InputState::Normal);
   }

   /* 64 - VT420 family
    *  1 - 132 columns
    *  9 - National Replacement Character-sets
    * 15 - DEC technical set
    * 21 - horizontal scrolling
    * 22 - color
    */
   #define DEVICE_ID "64;1;9;15;21;22c"

   inline void
   Vterm::csi_priDA ()
   {
      TRACE_FUN;
      writePty ("\e[?" DEVICE_ID);
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_secDA ()
   {
      TRACE_FUN;
      writePty ("\e[>64;0;0c"); // VT520
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_DSR ()
   {
      TRACE_FUN;
      switch (inputOps [0])
      {
      case 5:
         writePty ("\e[0n"); // device OK
         break;
      case 6:
      {
         std::ostringstream oss;
         if (originMode == OriginMode::Absolute)
            oss << "\e[" << (posY + 1) << ";" << (posX + 1) << "R";
         else
            oss << "\e[" << (posY - cf->marginTop + 1) << ";" << (posX + 1) << "R";
         writePty (oss.str ().c_str ());
      }
         break;
      default:
         break;
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::esch_DECALN ()
   {
      TRACE_FUN;

      // Save current attrs
      CharVdev::Cell origAttrs = attrs;
      CharVdev::Color* origFg = &attrs.fg;
      CharVdev::Color* origBg = &attrs.bg;

      resetAttrs ();
      fillScreen ('E');

      // Restore attrs
      fg = origFg;
      bg = origBg;
      attrs = origAttrs;

      setState (InputState::Normal);
   }

   inline void
   Vterm::esc_RIS ()
   {
      TRACE_FUN;
      resetTerminal ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_DECSTR ()
   {
      TRACE_FUN;
      resetScreen ();
      resetAttrs ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::handle_DCS ()
   {
      TRACE_FUN;
      auto arg = std::string ((char*)argBuf.data (), argBuf.size ());
      if (arg == "$q\"p")
      {
         // DECSCL
         writePty ("\eP1$r" DEVICE_ID "\e\\");
      }
      else
      {
         logU << "DCS: '" << arg << "'" << std::endl;
         std::ostringstream oss;
         oss << "\eP0$r";
         oss << arg.substr (2);
         oss << "\e\\";
         writePty (oss.str ().c_str ());
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::handle_OSC ()
   {
      TRACE_FUN;
      auto arg = std::string ((char*)argBuf.data (), argBuf.size ());
      logU << "OSC: '" << arg << "'" << std::endl;
      setState (InputState::Normal);
   }

   inline void
   Vterm::csiq_DECSCL ()
   {
      TRACE_FUN;
      if (nInputOps > 0)
      {
         switch (inputOps [0])
         {
         case 61: compatLevel = CompatibilityLevel::VT100; break;
         case 62: compatLevel = CompatibilityLevel::VT400; break;
         case 63: compatLevel = CompatibilityLevel::VT400; break;
         case 64: compatLevel = CompatibilityLevel::VT400; break;
         case 65: compatLevel = CompatibilityLevel::VT400; break;
         default:
            logU << "DECSCL: compatibility mode " << inputOps [0] << std::endl;
            break;
         }
      }
      if (nInputOps > 1)
      {
         switch (inputOps [1])
         {
         case 0: logT << "DECSCL: 8-bit controls" << std::endl; break;
         case 1: logT << "DECSCL: 7-bit controls" << std::endl; break;
         case 2: logT << "DECSCL: 8-bit controls" << std::endl; break;
         default:
            logU << "DECSCL: C1 control transmission mode: "
                 << inputOps [1] << std::endl;
            break;
         }
      }
      setState (InputState::Normal);
   }

} // namespace zutty
