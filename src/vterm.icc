/* -*- C++ -*-
 * This file is part of Zutty.
 * Copyright (C) 2020 Tom Szilagyi
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * See the file LICENSE for the full license.
 */

#include "pty.h"

#include <algorithm>
#include <iostream>
#include <sstream>

// for the debug/step facility:
#include <chrono>
#include <thread>
#include <sys/types.h>
#include <signal.h>

namespace {

   using namespace zutty;

#define LOG
//#define LOG_TRACE
//#define STEP_DEBUGGER

#ifdef LOG
   #define logE      std::cout << "Error: "
   #define logEcont  std::cout
   #define logU      std::cout << "(unimpl) "
   #define logUcont  std::cout
   #define logI      std::cout << "Info | "
#else
   #define logE      nullptr && std::cout
   #define logEcont  nullptr && std::cout
   #define logU      nullptr && std::cout
   #define logUcont  nullptr && std::cout
   #define logI      nullptr && std::cout
#endif

#ifdef LOG_TRACE
   #define logT      std::cout << "Trace | "
   #define logTcont  std::cout
   #define TRACE_FUN                           \
      logT << __FUNCTION__ << " [";            \
      for (size_t k = 0; k < nInputOps; ++k) { \
         if (k) logTcont << ";";               \
         logTcont << inputOps [k];             \
      }                                        \
      logTcont << "]   \t"                     \
      << "p(" << posY << "," << posX           \
      << ")  d(" << nRows << "," << nCols      \
      << ")  mgn[" << marginTop << "," << marginBottom  \
      << ")  cur=" << cur                      \
      << "  head=" << scrollHead               \
      << std::endl

#else
   #define logT      nullptr && std::cout
   #define logTcont  nullptr && std::cout
   #define TRACE_FUN
#endif

   inline int
   debugPrintInput (std::ostream & os,
                    unsigned char* start, unsigned char* end,
                    bool breakOnEsc = false)
   {
      int count = 0;
      os << "'";
      for (auto it = start; it != end; ++it)
      {
         if (breakOnEsc && *it == '\e')
            break;
         switch (*it)
         {
         case '\a': os << "\\a"; break;
         case '\b': os << "\\b"; break;
         case '\e': os << "\\e"; break;
         case '\f': os << "\\f"; break;
         case '\n': os << "\\n"; break;
         case '\r': os << "\\r"; break;
         case '\t': os << "\\t"; break;
         case '\v': os << "\\v"; break;
         case '\x7f': os << "<DEL>"; break;
         default:
            if (*it < ' ')
               os << "<" << (unsigned int)*it << ">";
            else
               os << *it;
            break;
         }
         ++count;
      }
      os << "' (" << count << " bytes)" << std::endl;
      return count;
   }

   // Dummy override for when log* streams are defined to nullptr
   inline int
   debugPrintInput (bool, unsigned char*, unsigned char*, bool = false)
   { return 0; }
}

namespace zutty {

#ifdef STEP_DEBUGGER
   #define DEBUGSTOP debugStop()

   inline void
   Vterm::debugStop ()
   {
      logT << "*** DEBUG STOP, "
           << readPos + 1 - lastStopPos << " bytes since last:\n        ";
      debugPrintInput (logTcont, inputBuf + lastStopPos, inputBuf + readPos + 1);
      lastStopPos = readPos + 1;

      logT << "Issue 'kill -CONT " << getpid () << "' or 'fg' to continue."
           << std::endl;

      refreshVideo (* this);
      using namespace std::chrono_literals;
      std::this_thread::sleep_for (100ms);

      kill (getpid (), SIGSTOP);
   }
#else
   #define DEBUGSTOP
#endif // STEP_DEBUGGER

   inline void
   Vterm::unhandledInput (char ch)
   {
      logE << "Unhandled input char '" << ch
           << "' (" << (unsigned int)ch << ") in state " << (int)inputState
           << ". Escape sequence so far: ";
      debugPrintInput (logEcont, inputBuf + lastEscBegin, inputBuf + readPos + 1);
      setState (InputState::Normal);
   }

   inline void
   Vterm::traceNormalInput ()
   {
   #ifdef LOG_TRACE
      if (lastNormalBegin < readPos)
      {
         std::ostringstream oss;
         oss << "Inserted: ";
         if (debugPrintInput (oss, inputBuf + lastNormalBegin,
                              inputBuf + readPos, true))
            logT << oss.str ();
      }
      lastNormalBegin = readPos + 1;
   #endif
   }

   inline void
   Vterm::resetTerminal ()
   {
      resetScreen ();
      resetAttrs ();
      fillScreen (' ');

      showCursorMode = true;
      altScreenBufferMode = false;
      autoWrapMode = true;
      autoNewlineMode = false;
      insertMode = false;
      bkspSendsDel = true;

      compatLevel = CompatibilityLevel::VT400;
      cursorKeyMode = CursorKeyMode::ANSI;
      numpadMode = NumpadMode::Numeric;
      originMode = OriginMode::Absolute;

      setState (InputState::Normal);
   }

   inline void
   Vterm::resetScreen ()
   {
      posX = 0;
      posY = 0;
      scrollHead = 0;
      marginTop = 0;
      marginBottom = nRows;
      setCur ();

      tabStops.clear ();
      savedCursor_SCO.isSet = false;
      savedCursor_DEC.isSet = false;

      fillScreen (' ');
   }

   inline void
   Vterm::resetAttrs ()
   {
      fg = &attrs.fg;
      bg = &attrs.bg;

      inputOps [0] = 0;
      nInputOps = 1;
      csi_SGR ();
   }

   inline void
   Vterm::fillScreen (uint16_t ch)
   {
      for (uint32_t k = 0; k < nRows * nCols; ++k)
      {
         cell (k) = attrs;
         cell (k).uc_pt = ch;
      }
   }

   inline void
   Vterm::linearizeCellStorage ()
   {
      auto newCells = std::shared_ptr <CharVdev::Cell> (
         new CharVdev::Cell [nRows * nCols]);
      copyCells (newCells.get ());
      cells = newCells;
      scrollHead = marginTop * nCols;
   }

   inline void
   Vterm::setState (InputState newState)
   {
      if (newState == inputState)
         return;

      if (newState == InputState::Normal)
      {
         DEBUGSTOP;
         nInputOps = 0;
         inputOps [0] = 0;
         lastNormalBegin = readPos + 1;
      }
      else
      {
         traceNormalInput ();
      }

      inputState = newState;
   }

   inline int
   Vterm::writePty (uint8_t ch)
   {
      logT << "pty write: ";
      auto uch = (unsigned char*)&ch;
      debugPrintInput (logTcont, uch, uch + 1);
      return write (ptyFd, &ch, 1);
   }

   inline int
   Vterm::writePty (const char* cstr)
   {
      logT << "pty write: ";
      auto ucstr = (unsigned char*)cstr;
      debugPrintInput (logTcont, ucstr, ucstr + strlen (cstr));
      return write (ptyFd, cstr, strlen (cstr));
   }

   inline void
   Vterm::readPty ()
   {
      ssize_t n = read (ptyFd, inputBuf, sizeof (inputBuf));

      logT << "pty read: ";
      debugPrintInput (logTcont, inputBuf, inputBuf + n);

      readPos = 0;
      lastEscBegin = 0;
      lastNormalBegin = 0;
      lastStopPos = 0;
      hideCursor ();
      for (readPos = 0; readPos < n; ++readPos)
      {
         const char& ch = inputBuf [readPos];
         switch (inputState)
         {
         case InputState::Normal:
            switch (ch)
            {
            case '\x00': // ignore
               break;
            case '\e':
               setState (InputState::Escape);
               inputOps [0] = 0;
               nInputOps = 1;
               lastEscBegin = readPos;
               break;
            case '\r': traceNormalInput (); inp_CR (); break;
            case '\f': // fall through, treat as LineFeed ('\n')
            case '\v': // fall through, treat as LineFeed ('\n')
            case '\n': traceNormalInput (); esc_IND (); break;
            case '\t': traceNormalInput (); inp_HT (); break;
            case '\b': traceNormalInput (); csi_CUB (); break;
            case '\a':
               traceNormalInput ();
               logI << "* Bell *" << std::endl;
               break;
            case 0x0e:
               traceNormalInput ();
               //logU << "Locking Shift 1: map G1 to GL" << std::endl;
               break;
            case 0x0f:
               traceNormalInput ();
               //logU << "Locking Shift 0: map G0 to GL" << std::endl;
               break;
            case 0x05:
               traceNormalInput ();
               writePty ("This is Zutty.\r\n");
               break;
            default:
               if ((ch & 0x80) == 0)
               {
                  unicode_cp = ch;
                  placeGraphicChar ();
               }
               else if (((uint8_t)ch >> 6) == 0x2) // 10xx'xxxx
               {
                  logT << "utf-8 sequence cont" << std::endl;
                  unicode_cp <<= 6;
                  unicode_cp += (uint8_t)ch & 0x3f;
                  if (! --utf8_rem)
                     placeGraphicChar ();
              }
               else if (((uint8_t)ch >> 5) == 0x6) // 110x'xxxx
               {
                  logT << "utf-8 2-byte sequence" << std::endl;
                  unicode_cp = ch & 0x1f;
                  utf8_rem = 1;
               }
               else if (((uint8_t)ch >> 4) == 0xe) // 1110'xxxx
               {
                  logT << "utf-8 3-byte sequence" << std::endl;
                  unicode_cp = ch & 0x0f;
                  utf8_rem = 2;
               }
               else if (((uint8_t)ch >> 3) == 0x1e) // 1111'0xxx
               {
                  logT << "utf-8 4-byte sequence" << std::endl;
                  unicode_cp = ch & 0x07;
                  utf8_rem = 3;
               }
            }
            break;
         case InputState::Escape:
            switch (ch)
            {
            case '\e': setState (InputState::Normal); break;
            case '#': setState (InputState::EscapeHash); break;
            case '[': setState (InputState::CSI); break;
            case '(': setState (InputState::SelectCharset); break;
            case ')': setState (InputState::SelectCharset); break;
            case '*': setState (InputState::SelectCharset); break;
            case '+': setState (InputState::SelectCharset); break;
            case 'D': esc_IND (); break;
            case 'M': esc_RI (); break;
            case 'E': esc_NEL (); break;
            case 'H': esc_HTS (); break;
            case 'c': esc_RIS (); break;
            case '6': esc_BI (); break;
            case '7': esc_DECSC (); break;
            case '8': esc_DECRC (); break;
            case '9': esc_FI (); break;
            case '=': numpadMode = NumpadMode::Application;
               logU << "Application keypad mode" << std::endl;
               setState (InputState::Normal);
               DEBUGSTOP;
               break;
            case '>': numpadMode = NumpadMode::Numeric;
               logU << "Numeric keypad mode" << std::endl;
               setState (InputState::Normal);
               break;
            case 'P':
               setState (InputState::DCS);
               argBuf.clear ();
               break;
            default:
               unhandledInput (ch);
               break;
            }
            break;
         case InputState::EscapeHash:
            switch (ch)
            {
            case '8': esch_DECALN (); break;
            default: unhandledInput (ch); break;
            }
            break;
         case InputState::SelectCharset:
            logT << "Designate Character Set: input '" << ch << "'"
                 << std::endl;
            if (ch >= 0x30) // Final
               setState (InputState::Normal);
            break;
         case InputState::CSI:
            switch (ch)
            {
            case '\e': setState (InputState::Normal); break;
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
               inputOps [nInputOps - 1] *= 10;
               inputOps [nInputOps - 1] += ch - '0';
               break;
            case ';':
               if (nInputOps < maxEscOps)
                  inputOps [nInputOps ++] = 0;
               else
               {
                  logE << "inputOps full, increase maxEscOps (currently: "
                       << maxEscOps << ")!" << std::endl;
                  setState (InputState::Normal);
               }
               break;
            case 'A': csi_CUU (); break;
            case 'B': csi_CUD (); break;
            case 'C': csi_CUF (); break;
            case 'D': csi_CUB (); break;
            case 'E': csi_CNL (); break;
            case 'F': csi_CPL (); break;
            case 'G': csi_CHA (); break;
            case 'H': case 'f': csi_CUP (); break;
            case 'I': csi_CHT (); break;
            case 'J': csi_ED (); break;
            case 'K': csi_EL (); break;
            case 'L': csi_IL (); break;
            case 'M': csi_DL (); break;
            case 'P': csi_DCH (); break;
            case 'S': csi_SU (); break;
            case 'T': csi_SD (); break;
            case 'X': csi_ECH (); break;
            case 'Z': csi_CBT (); break;
            case '@': csi_ICH (); break;
            case '`': csi_HPA (); break;
            case 'a': csi_HPR (); break;
            case 'b': csi_REP (); break;
            case 'c': csi_priDA (); break;
            case 'd': csi_VPA (); break;
            case 'g': csi_TBC (); break;
            case 'h': csi_SM (); break;
            case 'l': csi_RM (); break;
            case 'm': csi_SGR (); break;
            case 'n': csi_DSR (); break;
            case 'r': csi_STBM (); break;
            case 's': csi_SCOSC (); break;
            case 'u': csi_SCORC (); break;
            case '\"': setState (InputState::CSI_Quote); break;
            case '!': setState (InputState::CSI_Bang); break;
            case '?': setState (InputState::CSI_priv); break;
            case ' ': setState (InputState::CSI_SPC); break;
            case '\a': break; // ignore
            case '\b': // undo last character in CSI sequence:
               if (readPos && inputBuf [readPos - 1] == ';')
                  --nInputOps;
               else
                  inputOps [nInputOps - 1] /= 10;
               break;
            case '\t': inp_HT (); setState (InputState::CSI); break;
            case '\r': inp_CR (); setState (InputState::CSI); break;
            case '\f': // fall through
            case '\v': esc_IND (); setState (InputState::CSI); break;
            default: unhandledInput (ch); break;
            }
            break;
         case InputState::CSI_Bang:
            switch (ch)
            {
            case 'p': esc_RIS (); break;
            default: unhandledInput (ch); break;
            }
            break;
         case InputState::CSI_Quote:
            switch (ch)
            {
            case 'p': csiq_DECSCL (); break;
            default: unhandledInput (ch); break;
            }
            break;
         case InputState::CSI_SPC:
            switch (ch)
            {
            case '@': csi_ecma48_SL (); break;
            case 'A': csi_ecma48_SR (); break;
            default: unhandledInput (ch); break;
            }
            break;
         case InputState::CSI_priv:
            switch (ch)
            {
            case '\e': setState (InputState::Normal); break;
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
               inputOps [nInputOps - 1] *= 10;
               inputOps [nInputOps - 1] += ch - '0';
               break;
            case ';':
               if (nInputOps < maxEscOps)
                  inputOps [nInputOps ++] = 0;
               else
               {
                  logE << "inputOps full, increase maxEscOps (currently: "
                       << maxEscOps << ")!" << std::endl;
                  setState (InputState::Normal);
               }
               break;
            case 'h': csi_privSM (); break;
            case 'l': csi_privRM (); break;
            default: unhandledInput (ch); break;
            }
            break;
         case InputState::DCS:
            switch (ch)
            {
            case '\e': setState (InputState::DCS_Escape); break;
            default: argBuf.push_back (ch); break;
            }
            break;
         case InputState::DCS_Escape:
            switch (ch)
            {
            case '\\': handle_DCS (); break;
            default:
               argBuf.push_back ('\e');
               argBuf.push_back (ch);
               setState (InputState::DCS);
               break;
            }
            break;
         }
      }
      traceNormalInput ();
      showCursor ();
      refreshVideo (* this);
   }

   inline CharVdev::Cell &
   Vterm::cell (uint32_t idx)
   {
#if 1 /* strict / debug */
      if (idx >= nRows * nCols)
      {
         logE << "cell accessor: idx=" << idx
              << " out of range, size=" << nRows * nCols
              << std::endl;
         throw std::runtime_error ("cell accessor: index out of bounds");
      }
#endif
      return cells.get () [idx];
   }

   inline CharVdev::Cell &
   Vterm::cell (uint16_t row, uint16_t col)
   {
#if 1 /* strict / debug */
      if (row >= nRows || col >= nCols)
      {
         logE << "cell accessor: " << row << "," << col
              << " out of range, size=" << nRows << "," << nCols
              << std::endl;
         throw std::runtime_error ("cell accessor: index out of bounds");
      }
#endif
      uint32_t idx = getIdx (row, col);
      return cells.get () [idx];
   }

   inline uint32_t
   Vterm::getIdx (uint16_t pY, uint16_t pX)
   {
      if (pY < marginTop)
         return nCols * pY + pX;
      else if (pY < marginBottom)
         return nCols * marginTop +
            (scrollHead + (pY - 2 * marginTop) * nCols + pX) %
            ((marginBottom - marginTop) * nCols);
      else
         return nCols * pY + pX;
   }

   inline uint32_t
   Vterm::setCur ()
   {
      cur = getIdx (posY, posX);
      return cur;
   }

   inline uint32_t
   Vterm::startOfThisLine ()
   {
      return cur - posX;
   }

   inline uint32_t
   Vterm::startOfNextLine ()
   {
      return cur - posX + nCols;
   }

   // N.B.: Only use this to erase (within) one line.
   // Use a series of eraseRow () calls to erase larger areas!
   inline void
   Vterm::eraseRange (uint32_t start, uint32_t end)
   {
      for (uint32_t k = start; k < end; ++k)
         cell (k) = attrs;
   }

   inline void
   Vterm::eraseRow (uint16_t pY)
   {
      uint32_t idx = getIdx (pY, 0);
      eraseRange (idx, idx + nCols);
   }

   inline void
   Vterm::copyRow (uint16_t dstY, uint16_t srcY)
   {
      uint32_t dstIdx = getIdx (dstY, 0);
      uint32_t srcIdx = getIdx (srcY, 0);
      memcpy (cells.get () + dstIdx, cells.get () + srcIdx,
              nCols * sizeof (CharVdev::Cell));
   }

   // insert lines at and below posY, within the scrolling area
   inline void
   Vterm::insertLines (uint16_t count)
   {
      logT << "insertLines: count=" << count << std::endl;

      for (uint16_t pY = marginBottom - count - 1; pY >= posY; --pY)
      {
         copyRow (pY + count, pY);
         if (!pY) break;
      }

      for (uint16_t pY = posY; pY < posY + count; ++pY)
         eraseRow (pY);
   }

   // delete lines at and below posY, within the scrolling area
   inline void
   Vterm::deleteLines (uint16_t count)
   {
      logT << "deleteLines: count=" << count << std::endl;

      for (uint16_t pY = posY; pY < marginBottom - count; ++pY)
         copyRow (pY, pY + count);

      for (uint16_t pY = marginBottom - count; pY < marginBottom; ++pY)
         eraseRow (pY);
   }

   inline void
   Vterm::placeGraphicChar ()
   {
      if (! autoWrapMode && posX == nCols)
         return;

      normalizePosition ();

      if (insertMode)
      {
         nInputOps = 1;
         inputOps [0] = 1;
         csi_ICH ();
      }

      auto& c = cell (cur);
      c = attrs;
      c.uc_pt = unicode_cp;
      advancePosition ();
    }

   inline void
   Vterm::inp_LF ()
   {
      TRACE_FUN;
      esc_IND ();
      eraseRange (cur, startOfNextLine ());
   }

   inline void
   Vterm::inp_CR ()
   {
      TRACE_FUN;
      posX = 0;
      setCur ();
   }

   inline void
   Vterm::jumpToNextTabStop ()
   {
      if (tabStops.empty ())
      {
         // Hard default of 8 chars limited to right margin
         posX = std::min(((posX / 8) + 1) * 8, nCols - 1);
      }
      else
      {
         // Next tabstop column set, or the right margin
         auto ts = std::lower_bound (tabStops.begin (), tabStops.end (), posX);
         posX = (ts == tabStops.end ()) ? nCols - 1 : * ts;
      }
      setCur ();
   }

   inline void
   Vterm::inp_HT ()
   {
      TRACE_FUN;
      if (posX == nCols)
      {
         inp_CR ();
         esc_IND ();
      }
      else
         jumpToNextTabStop ();
   }

   inline void
   Vterm::normalizePosition ()
   {
      if (posX == nCols)
      {
         inp_CR ();
         inp_LF ();
      }
   }

   inline void
   Vterm::advancePosition ()
   {
      ++posX;
      setCur ();
   }

   inline void
   Vterm::showCursor ()
   {
      TRACE_FUN;
      if (showCursorMode)
         cell (cur).inverse = 1;
   }

   inline void
   Vterm::hideCursor ()
   {
      TRACE_FUN;
      cell (cur).inverse = 0;
   }

   inline void
   Vterm::esc_IND ()
   {
      TRACE_FUN;
      if (posY == marginBottom - 1)
      {
         nInputOps = 1;
         inputOps [0] = 1;
         csi_SU ();
      }
      else if (posY < nRows - 1)
      {
         ++posY;
         setCur ();
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::esc_RI ()
   {
      TRACE_FUN;
      if (posY == marginTop)
      {
         nInputOps = 1;
         inputOps [0] = 1;
         csi_SD ();
      }
      else if (posY > 0)
      {
         --posY;
         setCur ();
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_ecma48_SL ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1u;
      arg = std::min (arg, nCols);
      // move all lines to the left by arg positions:
      for (uint16_t r = 0; r < nRows; ++r)
      {
         CharVdev::Cell* p = cells.get () + nCols * r;
         memmove (p, p + arg, (nCols - arg) * sizeof (CharVdev::Cell));
         eraseRange (nCols * (r + 1) - arg, nCols * (r + 1));
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_ecma48_SR ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1u;
      arg = std::min (arg, nCols);
      // move all lines to the right by arg positions:
      for (uint16_t r = 0; r < nRows; ++r)
      {
         CharVdev::Cell* p = cells.get () + nCols * r;
         memmove (p + arg, p, (nCols - arg) * sizeof (CharVdev::Cell));
         eraseRange (nCols * r, nCols * r + arg);
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::esc_FI ()
   {
      TRACE_FUN;
      nInputOps = 1;
      inputOps [0] = 1;
      if (posX < nCols - 1)
         csi_CUF ();
      else
         csi_ecma48_SL ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::esc_BI ()
   {
      TRACE_FUN;
      nInputOps = 1;
      inputOps [0] = 1;
      if (posX > 0)
         csi_CUB ();
      else
         csi_ecma48_SR ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::esc_NEL ()
   {
      TRACE_FUN;
      esc_IND ();
      posX = 0;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::esc_HTS ()
   {
      TRACE_FUN;
      tabStops.push_back (posX);
      std::sort (tabStops.begin (), tabStops.end ());
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_SCOSC ()
   {
      TRACE_FUN;
      savedCursor_SCO.posX = posX;
      savedCursor_SCO.posY = posY;
      savedCursor_SCO.isSet = true;
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_SCORC ()
   {
      TRACE_FUN;
      if (!savedCursor_SCO.isSet)
      {
         logI << "Asked to restore cursor (SCORC) but it has not been saved."
              << std::endl;
      }
      else
      {
         posX = savedCursor_SCO.posX;
         posY = savedCursor_SCO.posY;
         setCur ();
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::esc_DECSC ()
   {
      TRACE_FUN;
      savedCursor_DEC.posX = posX;
      savedCursor_DEC.posY = posY;
      savedCursor_DEC.attrs = attrs;
      savedCursor_DEC.autoWrapMode = autoWrapMode;
      savedCursor_DEC.originMode = originMode;
      savedCursor_DEC.isSet = true;
      setState (InputState::Normal);
   }

   inline void
   Vterm::esc_DECRC ()
   {
      TRACE_FUN;
      if (!savedCursor_DEC.isSet)
      {
         logI << "Asked to restore cursor (DECRC) but it has not been saved."
              << std::endl;
      }
      else
      {
         posX = savedCursor_DEC.posX;
         posY = savedCursor_DEC.posY;
         setCur ();
         attrs = savedCursor_DEC.attrs;
         autoWrapMode = savedCursor_DEC.autoWrapMode;
         originMode = savedCursor_DEC.originMode;
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CUU ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      if (posY >= marginTop)
         arg = std::min ((int)arg, posY - marginTop);
      else
         arg = std::min (arg, posY);
      posY -= arg;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CUD ()
   {
      TRACE_FUN;
      int arg = inputOps [0] ? inputOps [0] : 1;
      if (posY < marginBottom)
         arg = std::min (arg, marginBottom - posY - 1);
      else
         arg = std::min (arg, nRows - posY - 1);
      posY += arg;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CUF ()
   {
      TRACE_FUN;
      int arg = inputOps [0] ? inputOps [0] : 1;
      arg = std::min (arg, nCols - posX - 1);
      posX += arg;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CUB ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      arg = std::min (arg, posX);
      if (posX == nCols)
         arg = std::min (arg + 1, (int)posX);
      posX -= arg;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CNL ()
   {
      TRACE_FUN;
      csi_CUD ();
      inp_CR ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CPL ()
   {
      TRACE_FUN;
      csi_CUU ();
      inp_CR ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CHA ()
   {
      TRACE_FUN;
      uint16_t col = inputOps [0] ? inputOps [0] : 1;
      col = std::max ((uint16_t)1, std::min (col, nCols));
      posX = col - 1;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_HPA ()
   {
      TRACE_FUN;
      csi_CHA ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_HPR ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      inputOps [0] = posX + arg + 1;
      csi_CHA ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_VPA ()
   {
      TRACE_FUN;
      uint16_t row = inputOps [0] ? inputOps [0] : 1;
      row = std::max ((uint16_t)1, std::min (row, nRows));
      posY = row - 1;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CUP ()
   {
      TRACE_FUN;
      uint16_t row = inputOps [0] ? inputOps [0] : 1;
      uint16_t col = (nInputOps > 1 && inputOps [1]) ? inputOps [1] : 1;
      switch (originMode)
      {
      case OriginMode::Absolute:
         row = std::max ((uint16_t)1, std::min (row, nRows)) - 1;
         break;
      case OriginMode::ScrollingRegion:
         row = std::max ((uint16_t)1, std::min (row, marginBottom)) - 1;
         row += marginTop;
         break;
      }
      col = std::max ((uint16_t)1, std::min (col, nCols)) - 1;

      posX = col;
      posY = row;
      setCur ();
      setState (InputState::Normal);
      logT << "Cursor positioned to (" << posY << "," << posX << ")"
           << std::endl;
   }

   inline void
   Vterm::csi_SU ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      for (uint16_t k = 0; k < arg; ++k)
      {
         scrollHead += nCols;
         if (scrollHead == marginBottom * nCols)
         {
            scrollHead = marginTop * nCols;
            eraseRange ((marginBottom - 1) * nCols, marginBottom * nCols);
         }
         else
         {
            eraseRange (scrollHead - nCols, scrollHead);
         }
      }
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_SD ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      for (uint16_t k = 0; k < arg; ++k)
      {
         if (scrollHead >= (marginTop + 1u) * nCols)
            scrollHead -= nCols;
         else
            scrollHead = (marginBottom - 1u) * nCols;
         eraseRange (scrollHead, scrollHead + nCols);
      }
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CHT ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      if (arg == 1)
         inp_HT ();
      else
         for (int k = 0; k < arg; ++k)
            jumpToNextTabStop ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_CBT ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      for (uint16_t k = 0; k < arg; ++k)
      {
         if (tabStops.empty ())
         {
            if (posX > 0 && posX % 8 == 0)
               posX -= 8;
            else
               posX = (posX / 8) * 8;
         }
         else
         {
            // Set posX to previous tab stop
            auto ts = std::lower_bound (tabStops.begin (), tabStops.end (), posX);
            if (ts != tabStops.begin ())
               posX = * (--ts);
            else
               posX = 0;
         }
         setCur ();
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_REP ()
   {
      TRACE_FUN;
      uint16_t arg = inputOps [0] ? inputOps [0] : 1;
      for (int k = 0; k < arg; ++k)
         placeGraphicChar ();
      unicode_cp = ' ';
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_ED ()
   {
      TRACE_FUN;
      switch (inputOps [0])
      {
      case 0: // clear from cursor to end of screen
         eraseRange (cur, startOfNextLine ());
         for (uint16_t pY = posY + 1; pY < nRows; ++pY)
            eraseRow (pY);
         break;
      case 1: // clear from beginning of screen to cursor
         for (uint16_t pY = 0; pY < posY; ++pY)
            eraseRow (pY);
         eraseRange (startOfThisLine (), cur + 1);
         break;
      case 2: // clear entire screen
         for (uint16_t pY = 0; pY < nRows; ++pY)
            eraseRow (pY);
         break;
      default:
         logI << "Erase in Display with illegal param: "
              << inputOps [0] << std::endl;
         break;
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_EL ()
   {
      TRACE_FUN;
      uint32_t begin = cur;
      uint32_t end = cur + 1;
      switch (inputOps [0])
      {
      case 0: // clear from cursor to end of line
         end = startOfNextLine ();
         break;
      case 1: // clear from cursor to beginning of line
         begin = startOfThisLine ();
         break;
      case 2: // clear entire line
         begin = startOfThisLine ();
         end = startOfNextLine ();
         break;
      default:
         logI << "Erase in Line with illegal param: "
              << inputOps [0] << std::endl;
         break;
      }
      eraseRange (begin, end);
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_IL ()
   {
      TRACE_FUN;
      if (posY < marginTop || posY >= marginBottom)
      {
         setState (InputState::Normal);
         return;
      }
      int arg = inputOps [0] ? inputOps [0] : 1;
      arg = std::min (arg, marginBottom - posY);
      insertLines (arg);
      inp_CR ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_DL ()
   {
      TRACE_FUN;
      if (posY < marginTop || posY >= marginBottom)
      {
         setState (InputState::Normal);
         return;
      }
      int arg = inputOps [0] ? inputOps [0] : 1;
      arg = std::min (arg, marginBottom - posY);
      deleteLines (arg);
      inp_CR ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_ICH ()
   {
      TRACE_FUN;
      uint32_t arg = inputOps [0] ? inputOps [0] : 1;
      uint32_t len = nCols - posX;
      arg = std::min (arg, len);
      len -= arg;
      memmove (cells.get () + cur + arg, cells.get () + cur,
               len * sizeof (CharVdev::Cell));
      eraseRange (cur, cur + arg);
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_DCH ()
   {
      TRACE_FUN;
      uint32_t arg = inputOps [0] ? inputOps [0] : 1;
      uint32_t len = nCols - posX;
      arg = std::min (arg, len);
      len -= arg;
      memmove (cells.get () + cur, cells.get () + cur + arg,
               len * sizeof (CharVdev::Cell));
      eraseRange (cur + len, cur + len + arg);
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_ECH ()
   {
      TRACE_FUN;
      uint32_t arg = inputOps [0] ? inputOps [0] : 1;
      uint32_t len = nCols - posX;
      arg = std::min (arg, len);
      eraseRange (cur, cur + arg);
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_STBM ()
   {
      TRACE_FUN;
      if (nInputOps == 1 && inputOps [0] == 0)
      {
         if (marginTop != 0 || marginBottom != nRows)
         {
            linearizeCellStorage ();
            marginTop = 0;
            marginBottom = nRows;
            scrollHead = 0;
         }
      }
      else if (nInputOps == 2)
      {
         uint16_t newMarginTop = inputOps [0] > 0 ? inputOps [0] - 1 : 0;
         uint16_t newMarginBottom = inputOps [1];

         if (newMarginBottom < newMarginTop + 2 || nRows < newMarginBottom)
         {
            logI << "Illegal arguments to SetTopBottomMargins: top="
                 << inputOps [0] << ", bottom=" << inputOps [1] << std::endl;
         }
         else if (newMarginTop != marginTop || newMarginBottom != marginBottom)
         {
            linearizeCellStorage ();
            marginTop = newMarginTop;
            marginBottom = newMarginBottom;
            scrollHead = marginTop * nCols;
         }
      }

      posX = 0;
      posY = marginTop;
      setCur ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_TBC ()
   {
      TRACE_FUN;
      switch (inputOps [0])
      {
      case 0:
      {
         auto it = std::find (tabStops.begin (), tabStops.end (), posX);
         if (it != tabStops.end ())
            tabStops.erase (it);
      }
         break;
      case 3:
         tabStops.clear ();
         break;
      default:
         break;
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_SM ()
   {
      TRACE_FUN;
      for (size_t k = 0; k < nInputOps; ++k)
      {
         const auto& arg = inputOps [k];

         switch (arg)
         {
         case 4: insertMode = true; break;
         case 20: autoNewlineMode = true; break;
         default:
            logU << "set mode " << arg << std::endl;
            break;
         }
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_RM ()
   {
      TRACE_FUN;
      for (size_t k = 0; k < nInputOps; ++k)
      {
         const auto& arg = inputOps [k];

         switch (arg)
         {
         case 4: insertMode = false; break;
         case 20: autoNewlineMode = false; break;
         default:
            logU << "reset mode " << arg << std::endl;
            break;
         }
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_privSM ()
   {
      TRACE_FUN;
      for (size_t k = 0; k < nInputOps; ++k)
      {
         const auto& arg = inputOps [k];

         switch (arg)
         {
         case 1: cursorKeyMode = CursorKeyMode::Application; break;
         case 2: compatLevel = CompatibilityLevel::VT100; break;
         case 3:
            resetScreen ();
            logT << "DECCOLM: Selected 132 columns per line" << std::endl;
            break;
         case 4:
            logT << "DECSCLM: Selected smooth scroll" << std::endl;
            break;
         case 5:
            logU << "DECSCNM: Selected inverse video mode" << std::endl;
            break;
         case 6: originMode = OriginMode::ScrollingRegion; break;
         case 7: autoWrapMode = true; break;
         case 8:
            logU << "DECARM: Auto-repeat mode enabled" << std::endl;
            break;
         case 12:
            logU << "Start blinking cursor" << std::endl;
            break;
         case 25: showCursorMode = true; break;
         case 67: bkspSendsDel = false; break;
         case 1000:
            logU << "Enable mouse tracking mode" << std::endl;
            break;
         case 1049: altScreenBufferMode = true;
            logU << "Enable alternative screen buffer" << std::endl;
            break;
         default:
            logU << "set priv mode " << arg << std::endl;
            break;
         }
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_privRM ()
   {
      TRACE_FUN;
      for (size_t k = 0; k < nInputOps; ++k)
      {
         const auto& arg = inputOps [k];

         switch (arg)
         {
         case 1: cursorKeyMode = CursorKeyMode::ANSI; break;
         case 2: compatLevel = CompatibilityLevel::VT52; break;
         case 3:
            resetScreen ();
            logT << "DECCOLM: Selected 80 columns per line" << std::endl;
            break;
         case 4:
            logT << "DECSCLM: Selected jump scroll" << std::endl;
            break;
         case 5:
            logU << "DECSCNM: Selected normal video mode" << std::endl;
            break;
         case 6: originMode = OriginMode::Absolute; break;
         case 7: autoWrapMode = false; break;
         case 8:
            logU << "DECARM: Auto-repeat mode disabled" << std::endl;
            break;
         case 12:
            logU << "Stop blinking cursor" << std::endl;
            break;
         case 25: showCursorMode = false; break;
         case 67: bkspSendsDel = true; break;
         case 1000:
            logU << "Disable mouse tracking mode" << std::endl;
            break;
         case 1049: altScreenBufferMode = false;
            logU << "Disable alternative screen buffer" << std::endl;
            break;
         default:
            logU << "reset priv mode " << arg << std::endl;
            break;
         }
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_SGR ()
   {
      TRACE_FUN;
      for (size_t k = 0; k < nInputOps; ++k)
      {
         const auto& attr = inputOps [k];

         switch (attr)
         {
         case 0:
            attrs.uc_pt = ' ';
            attrs.bold = 0;
            attrs.underline = 0;
            attrs.inverse = 0;
            attrs.fg = defaultFg;
            attrs.bg = defaultBg;
            fg = &attrs.fg;
            bg = &attrs.bg;
            break;
         case 1: attrs.bold = 1; break;
         case 2: attrs.bold = 0; break;
         case 3: attrs.inverse = 1; break; // italic
         case 4: attrs.underline = 1; break;
         case 7:
            std::swap (*fg, *bg);
            fg = &attrs.bg;
            bg = &attrs.fg;
            break;
         case 10: attrs.bold = 0; break;
         case 11: case 12: case 13: case 14: case 15:
         case 16: case 17: case 18: case 19: attrs.bold = 1; break;
         case 23: attrs.inverse = 0; break;
         case 24: attrs.underline = 0; break;
         case 27:
            std::swap (*fg, *bg);
            fg = &attrs.fg;
            bg = &attrs.bg;
            break;

         // standard foregrounds (bright if bold)
         case 30: *fg = attrs.bold ? palette256 [8] : palette256 [0]; break;
         case 31: *fg = attrs.bold ? palette256 [9] : palette256 [1]; break;
         case 32: *fg = attrs.bold ? palette256 [10] : palette256 [2]; break;
         case 33: *fg = attrs.bold ? palette256 [11] : palette256 [3]; break;
         case 34: *fg = attrs.bold ? palette256 [12] : palette256 [4]; break;
         case 35: *fg = attrs.bold ? palette256 [13] : palette256 [5]; break;
         case 36: *fg = attrs.bold ? palette256 [14] : palette256 [6]; break;
         case 37: *fg = attrs.bold ? palette256 [15] : palette256 [7]; break;

         case 38:
            if (k >= nInputOps - 1) break;
            switch (inputOps [++k])
            {
            case 5:
               if (k >= nInputOps - 1) break;
               *fg = palette256 [inputOps [++k]];
               break;
            case 2:
               if (k >= nInputOps - 3) break;
               (*fg).red   = inputOps [++k];
               (*fg).green = inputOps [++k];
               (*fg).blue  = inputOps [++k];
               break;
            default:
               break;
            }
            break;
         case 39: *fg = defaultFg; break;

         // standard backgrounds
         case 40: *bg = palette256 [0]; break;
         case 41: *bg = palette256 [1]; break;
         case 42: *bg = palette256 [2]; break;
         case 43: *bg = palette256 [3]; break;
         case 44: *bg = palette256 [4]; break;
         case 45: *bg = palette256 [5]; break;
         case 46: *bg = palette256 [6]; break;
         case 47: *bg = palette256 [7]; break;
         case 48:
            if (k >= nInputOps - 1) break;
            switch (inputOps [++k])
            {
            case 5:
               if (k >= nInputOps - 1) break;
               *bg = palette256 [inputOps [++k]];
               break;
            case 2:
               if (k >= nInputOps - 3) break;
               (*bg).red   = inputOps [++k];
               (*bg).green = inputOps [++k];
               (*bg).blue  = inputOps [++k];
               break;
            default:
               break;
            }
            break;
         case 49: *bg = defaultBg; break;

         // bright colored foregrounds
         case 90: *fg = palette256 [8]; break;
         case 91: *fg = palette256 [9]; break;
         case 92: *fg = palette256 [10]; break;
         case 93: *fg = palette256 [11]; break;
         case 94: *fg = palette256 [12]; break;
         case 95: *fg = palette256 [13]; break;
         case 96: *fg = palette256 [14]; break;
         case 97: *fg = palette256 [15]; break;

         // bright colored backgrounds
         case 100: *bg = palette256 [8]; break;
         case 101: *bg = palette256 [9]; break;
         case 102: *bg = palette256 [10]; break;
         case 103: *bg = palette256 [11]; break;
         case 104: *bg = palette256 [12]; break;
         case 105: *bg = palette256 [13]; break;
         case 106: *bg = palette256 [14]; break;
         case 107: *bg = palette256 [15]; break;

         default:
            logU << "attribute: " << attr << std::endl;
            break;
         }
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_priDA ()
   {
      TRACE_FUN;
      //writePty ("\e[?6c"); // vt102
      //writePty ("\e[?62;1;2;6;9c"); // vt220
      writePty ("\e[?" "64;1;2;6;9;15;18;19;21;22c"); // vt420
      setState (InputState::Normal);
   }

   inline void
   Vterm::csi_DSR ()
   {
      TRACE_FUN;
      switch (inputOps [0])
      {
      case 5:
         writePty ("\e[0n"); // device OK
         break;
      case 6:
      {
         std::ostringstream oss;
         if (originMode == OriginMode::Absolute)
            oss << "\e[" << (posY + 1) << ";" << (posX + 1) << "R";
         else
            oss << "\e[" << (posY - marginTop + 1) << ";" << (posX + 1) << "R";
         writePty (oss.str ().c_str ());
      }
         break;
      default:
         break;
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::esch_DECALN ()
   {
      TRACE_FUN;

      // Save current attrs
      CharVdev::Cell origAttrs = attrs;
      CharVdev::Color* origFg = &attrs.fg;
      CharVdev::Color* origBg = &attrs.bg;

      resetAttrs ();
      fillScreen ('E');

      // Restore attrs
      fg = origFg;
      bg = origBg;
      attrs = origAttrs;

      setState (InputState::Normal);
   }

   inline void
   Vterm::esc_RIS ()
   {
      TRACE_FUN;
      resetTerminal ();
      setState (InputState::Normal);
   }

   inline void
   Vterm::handle_DCS ()
   {
      TRACE_FUN;
      auto arg = std::string ((char*)argBuf.data (), argBuf.size ());
      if (arg == "$q\"p")
      {
         // DECSCL
         writePty ("\eP1$r" "64;1;2;6;9;15;18;21;22c" "\e\\");
      }
      else
      {
         logU << "DCS: '" << arg << "'" << std::endl;
         std::ostringstream oss;
         oss << "\eP0$r";
         oss << arg.substr (2);
         oss << "\e\\";
         writePty (oss.str ().c_str ());
      }
      setState (InputState::Normal);
   }

   inline void
   Vterm::csiq_DECSCL ()
   {
      TRACE_FUN;
      if (nInputOps == 2)
      {
         switch (inputOps [0])
         {
         case 61: compatLevel = CompatibilityLevel::VT100; break;
         case 62: compatLevel = CompatibilityLevel::VT400; break;
         case 63: compatLevel = CompatibilityLevel::VT400; break;
         case 64: compatLevel = CompatibilityLevel::VT400; break;
         case 65: compatLevel = CompatibilityLevel::VT400; break;
         default:
            logU << "DECSCL: compatibility mode " << inputOps [0] << std::endl;
            break;
         }

         switch (inputOps [1])
         {
         case 0: logT << "DECSCL: 8-bit controls" << std::endl; break;
         case 1: logT << "DECSCL: 7-bit controls" << std::endl; break;
         case 2: logT << "DECSCL: 8-bit controls" << std::endl; break;
         default:
            logU << "DECSCL: C1 control transmission mode: "
                 << inputOps [1] << std::endl;
            break;
         }
      }
      setState (InputState::Normal);
   }

} // namespace zutty
